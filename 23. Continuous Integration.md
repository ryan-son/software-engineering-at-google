# 23. 지속적 통합

> 지속적 통합: 팀원들이 작업 결과를 자주 통합하는 소프트웨어 개발 방식이다. 통합할 때마다 자동 빌드(테스트 포함)하여 통합 오류를 빠르게 찾아낸다.

- CI의 기본 목적은 문제를 일으키는 변경을 가능한 한 조기에 자동으로 발견해내는 것이다.
- 요즘 시스템들은 리포지터리 안의 코드 말고도 동적으로 변하는 요소가 많다.
  - 최근 유행하는 마이크로서비스 시스템에서는 문제의 원인이 코드베이스가 아니라 느슨하게 결합된 다른 마이크로서비스와의 네트워크 실패 때문인 경우가 많다.
  - 전통적인 지속적 빌드에서는 바이너리에서 변경된 기능을 테스트하지만 이를 확장하면 업스트림 마이크로서비스의 변경들도 테스트할 수 있다.
- 의존성들의 변경까지 모두 지속적으로 통합하는 걸 목표로 삼아야 한다.
- 변경되는 요소들의 소유자가 우리 팀, 조직, 회사 외부의 개발자일 수도 있다.

> 대규모 개발을 고려한 CI: 빠르게 진화하는 복잡한 생태계 전체를 지속적으로 조립하고 테스트하는 개발 방식

- 테스트라는 시각에서 CI는 다음을 알려주는 패러다임이다.
  - 코드(와 다른 요소)가 변경되어 지속적으로 통합되는 개발/릴리즈 워크플로에서 무슨(what) 테스트를 언제(when) 실행해야 하는가?
  - 워크플로의 각 테스트 지점에서 (적절한 충실성을 갖춘) 테스트 대상 시스템(SUT)을 (합리적인 비용으로) 어떻게(how) 구성해야 하는가?
- 각 테스트 지점(프리서브밋, 포스트서브밋, 스테이징 배포 전, ...)에서 SUT를 어떻게 구성할까?

## 23.1. 지속적 통합이란?

### 23.1.1 빠른 피드백 루프

- 버그는 발견하는 시점이 늦을수록 처리 비용이 기하급수적으로 증가한다.
- 코드 변경 과정에서 문제를 발견해낼 수 있는 위치들
  - 편집/컴파일/디버그 -> 프리서브밋 -> 포스트서브밋 -> 릴리즈 후보(RC) -> RC 승격(스테이징 등 임시 환경) -> 최종 RC 승격(프로덕션)
- 일반적으로 오른쪽 끝 가까이까지 살아남을수록 비용이 커지는 이유
  - 문제의 코드에 익숙하지 않은 엔지니어가 분류해야 한다.
  - 변경 작성자가 무엇을 왜 변경했는지 기억해내고 조사하는 노력이 더 많이 든다.
  - 바로 옆 동료부터 (마지막 단계까지 잡아내지 못하면) 최종 사용자까지, 다른 이들에게 부정적인 영향을 준다.
- CI는 빠른 **피드백 루프(fast feedback loop)**를 이용하도록 유도하여 버그 비용을 최소로 줄여준다. 코드 또는 다른 변경을 테스트 시나리오에 통합하고 결과를 관찰하기까지가 하나의 피드백 루프이다.
- 다양한 피드백의 형태(피드백이 빠른 순)
  - 로컬 개발 시의 편집-컴파일-디버그 루프
  - 프리서브밋 시 변경 작성자에게 주어지는 자동 테스트 결과
  - 두 프로젝트를 변경한 후 통합 시 오류. 양쪽 변경들을 서브밋한 다음 함께 테스트할 때 발견(예: 포스트서브밋)
  - 내 프로젝트와 업스트림 마이크로서비스 의존성 사이의 호환성 충돌. 업스트림 서비스의 최신 변경이 스테이징 환경에 배포될 때 QA 엔지니어가 발견
  - 기능을 먼저 이용해본 사내 이용자의 버그 리포트
  - 외부 고객 혹은 언론 매체의 버그 리포트 (혹은 서비스 장애 리포트)
- **카나리 배포(canary release)**를 활용하면 프로덕션에서 일어나는 문제가 확실히 줄어든다. 프로덕션 전체에 배포하기 전에 일부에만 먼저 배포하여 초기 피드백 루프를 만들 수 있기 때문이다. 하지만 여러 가지 버전이 동시에 배포되어 있으면 호환성 문제가 생길 수 있으니 카나리 배포 자체로 문제를 일으킬 여지도 있다.
- **버전 왜곡(version skew)**이라는 문제는 분산 시스템에 호환되지 않는 여러 코드, 데이터, 설정 정보(configuration)가 공존하는 상태를 말한다.
- **실험(experiment)**과 **기능 플래그(feature flag)**도 매우 강력한 피드백 루프이다. 변경을 컴포넌트 단위로 격리한 후 프로덕션 환경에서 동적으로 켜고 끌 수 있게 하여 배포 위험을 줄여주는 기법들이다.

#### 볼 수 있고 조치할 수 있는 피드백

- CI가 제공하는 피드백을 많은 사람이 볼 수 있어야 한다. 
- 구글은 통합 테스트 리포트 시스템을 이용하여 빌드 테스트 결과를 로그까지 누구든 쉽게 볼 수 있게 한다. 엔지니어가 로컬에서 수행한 빌드든 자동으로 수행되는 데브 혹은 스테이징 빌드든 모두 확인할 수 있다.
- 테스트 리포트 시스템은 빌드와 테스트의 실패 이력도 자세히 알려준다. 각 빌드(테스트)가 어디서 멈췄고, 어디서 실행했고, 누가 실행했는지도 알 수 있다. 분명한 실패인지 비결정적인 결과인지를 구분해주는 시스템도 마련했다.
- CI 테스트가 제공하는 피드백은 모두 조치가 가능해야 한다. 즉, 문제를 찾고 고치기가 쉬워야 한다. 테스트 출력 메시지의 가독성을 개선하면 피드백을 자동으로 이해하고 조치까지 자동으로 이루어지게 할 수 있다.

### 23.1.2 자동화

- 개발 관련 활동들을 자동화하면 장기적으로 엔지니어링 자원을 아낄 수 있다.
- 여러 개발 활동 중 CI는 특별히 빌드와 릴리즈 프로세스를 자동화한다. 각각을 따로 지속적 빌드와 지속적 배포라 한다. 지속적 테스트는 두 단계 모두에 자동으로 따라붙는다.

#### 지속적 빌드

- **지속적 빌드(continuous build, CB)**는 가장 최근의 코드 변경을 헤드(트렁크)에 통합한 다음 자동으로 빌드와 테스트를 수행한다.
- CB에서는 테스트도 빌드의 한 과정으로 보기 때문에 컴파일을 통과하더라도 테스트에 실패하면 빌드 실패로 간주한다.
- 모든 테스트에 통과하면 CB가 UI에 통과 혹은 녹색으로 표시한다.
- 이 프로세스로 인해 리포지터리에는 실질적으로 두 가지 버전의 헤드가 존재할 수 있다.
  - 참 헤드(true head) 최신 변경이 커밋된 버전
  - 녹색 헤드(green head): CB가 검증한 최신 변경

#### 지속적 배포

- 지속적 배포(Continuous Delivery, CD)의 첫 번째 단계는 릴리즈 자동화이다. 헤드로부터 지속해서 최신 코드와 설정 정보를 가져와서 릴리즈 후보를 만들어 내는 작업이다.
- 릴리즈 후보(Release Candidate, RC): 자동화된 프로세스가 만든, 서로 밀접하게 관련된 요소들로 구성된 배포 가능한 단위. 지속적 빌드를 통과한 코드, 설정 정보, 기타 의존성들을 조합해 만든다.
- 릴리즈 후보에는 설정 정보까지도 포함된다. 설정 정보는 RC가 어디로 승격되느냐에 따라 조금씩 다를 수 있지만 반드시 포함시켜야 하는 매우 중요한 정보이다.
- 설정 정보를 꼭 바이너리 자체에 포함시킬 필요는 없다. 실험이나 기능 플래그처럼 다양한 시나리오에 대응할 수 있도록 설정 정보를 동적으로 바꿀 수 있게 하라고 권장한다.
- 정적인 설정 정보들은 모두 릴리즈 후보에 묶어 승격시켜서 해당 코드와 함께 테스트되도록 해야 한다. 실제로 프로덕션 버그의 상당수가 설정이 잘못되어 발생한다.
- 구글은 정적 설정 정보를 코드와 함께 버전 관리하여 코드 리뷰 프로세스를 똑같이 거치게 한다.

> 지속적 배포: 지속해서 릴리즈 후보를 조립한 다음 다양한 환경에 차례로 승격시켜 테스트하는 활동. 프로덕션까지 승격시키는 경우도 있고 그렇지 않은 경우도 있다.

- 구글의 경우 바이너리들의 크기가 대체로 상당히 크기 때문에 프로덕션에 새로 반영되는 변경들의 피드백을 바로바로 받기 위해 바이너리 모두를 매번 밀어 넣기란 거의 불가능하다.
- 대신 주로 실험이나 기능 플래그를 활용하는 선택적 지속적 배포 전략을 택한다.
- RC가 운영 환경들에서 단계별로 승격될 때 이상적으로는 아티팩트들(예: 바이너리, 컨테이너)을 다시 컴파일하거나 빌드하지 않아야 한다. 로컬에서 개발할 때부터 도커 같은 컨테이너를 이용하면 환경을 옮겨도 RC의 일관성을 지켜내기가 쉬워진다. 비슷하게 쿠버네티스 같은 오케스트레이션 도구를 이용하면 배포 사이에 일관성을 유지하기가 더 유리하다.
- 구글은 환경 간 릴리즈와 배포를 일관되게 관리하여 초기 테스트부터 충실성을 끌어올렸다. 그 덕에 프로덕션에서 뒤늦게 문제가 터지는 빈도를 크게 줄였다.
