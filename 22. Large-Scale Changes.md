# 22. 대규모 변경

- 구글은 코드베이스 전반을 전면적으로 건드리는 변경을 원자적으로 수행한다는 어이디어를 포기했다.
- 경험에 따르면 코드베이스와 엔지니어 수가 늘어날수록 원자적으로 수행할 수 있는 변경의 크기는 줄어든다.

## 2.2.1 대규모 변경(Large-Scale Changes, LSC)이란?

- 논리적으로 연관되어 있으나 현실적인 한계 때문에 원자적으로 서브밋할 수 없는 변경들의 집합
- LSC로 인해 생성되는 변경
  - 코드베이스 전반을 훑는 분석 도구로 찾은 공통 안티패턴 청소
  - 폐기 대상 API 호출 대체
  - (컴파일러 업그레이드 등) 저수준 인프라 개선사항 활성화
  - 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션

## 22.2 누가 대규모 변경을 처리하나?

- 구글에서는 상당 비중을 인프라팀들이 수행한다. 하지만 LSC 도구들과 지원 자원들은 누구나 이용할 수 있다.
- 새로운 클래스, 함수, 시스템을 만든 후 사용자 모두에게 새 버전을 쓰도록 강제하지 않는 이유?
  1. 하부 시스템을 구축하고 관리하는 인프라팀들은 그 시스템을 활용하는 수만 개의 참조를 수정하는 데 필요한 도메인 지식도 갖추고 있다. 인프라를 이용하는 팀들은 이런 마이그레이션을 처리하는 방법을 모를 가능 성이 크다.
  2. 합당한 보상 없이 할 일만 늘어나는 상황을 좋아할 사람은 없다. 새 시스템이 기존 시스템보다 낫더라도 팀에 따라서는 자발적으로 업그레이드할 만한 매력을 느끼지 못할 수도 있다. 반드시 마이그레이션해야 할 만큼 새로운 시스템이 중요하다면 비용을 조직 차원에서 부담하는 게 맞다.
  3. 대규모로 변경해야 할 시스템을 소유한 팀이 주도해야 변경을 완료하는 데 유리하다.
  
## 22.3 원자적 변경을 가로막는 요인

- 구글의 LSC 프로세스를 이해하려면 왜 수많은 변경들이 원자적으로 커밋될 수 없는지 이해해야 한다.

### 22.3.1 기술적 한계

- 대부분 버전 관리 시스템(VCS)에서는 기능을 수행하는 비용이 변경의 크기에 비례해 커진다. 파일 수십 개 규모의 작은 커밋은 무리없이 처리해주지만 파일 수천 개를 원자적으로 커밋하기에는 메모리나 프로세싱 능력이 부족할 수 있다.
- 중앙집중형 VCS에서는 커밋 중에는 다른 사용자가 쓰기 작업을 하지 못한다. 거대한 커밋은 다른 사용자들의 일을 멈춰세운다.

### 22.3.2 병합 충돌

- 변경의 규모가 커질수록 병합 시 충돌이 생길 가능성이 커진다.
- 변경에 포함되는 파일이 많아질수록 병합 충돌이 나타날 확률이 높아지며, 같은 리포지터리를 이용하는 엔지니어가 많을수록 문제는 더욱 복잡해진다.

### 22.3.3 유령의 묘지

- 유령의 묘지: 너무 오래되고 둔하고 복잡해서 아무도 손대려 하지 않는 시스템. 흔히 사업상 아주 중요한 시스템 중인 경우가 많다.
- LSC 관점에서 유령의 묘지는 모든 형태의 의미 있는 진보를 가로막는다.
- 충실한 테스트는 유령의 묘지 퇴출에 아주 효과적이다. 소프트웨어가 철저하게 테스트된다면 변경해도 이상이 생기지 않으리라는 믿음이 생긴다.

### 22.3.4 이질성(Heterogeneity)

- LSC가 가능하려면 LSC에 수반되는 작업 대부분을 사람이 아니라 컴퓨터가 처리해줘야 한다.
- 컴퓨터가 변경 코드를 정확한 위치에 올바르게 반영하려면 환경이 일관되어야 한다. 하나의 조직에서 다양한 VCS와 CI 시스템을 운영하고 프로젝트별로 도구와 스타일 가이드가 다르다면 코드베이스 전체를 아우르는 변경은 진행하기 어렵다. 반대로 환경을 단순화해 일관성을 높이면 인력을 재배치할 때도 좋고 컴퓨터가 변경을 자동으로 수행하는 데도 좋다.

### 22.3.5 테스트

- 모든 변경은 테스트되어야 한다. 하지만 변경의 덩치가 커지면 제대로 테스트하기가 훨씬 어렵다.
- 작은 변경을 자주 진행하면 같은 테스트들이 여러 번 실행된다. 테스트가 실패한 원인을 추적하는 데 드는 엔지니어의 시간은 이런 추가 테스트들을 수행하는 컴퓨팅 시간보다 훨씬 비싼 자원이므로 구글은 기꺼이 절충했다.

#### 사례 연구: 대규모 변경 테스트하기

- 테스트 자동화 플랫폼(Test Automation Platform, TAP) 열차
- TAP 열차가 유용한 이유
  - LSC는 대부분 순수한 리팩터링이라서 주제 범위가 매우 좁고 코드의 원래 의미가 달라지지 않는다.
  - LSC를 구성하는 개별 변경은 단순하고 면밀히 검토해 진행하므로 잘못될 가능성이 크지 않다.
- 열차는 다음 다섯 단계로 진행되며, 3시간마다 새로 출발한다.
  1. 열차에 실린 변경 각가에 대해 무작위로 선택한 테스트 1,000개를 수행한다.
  2. 1,000개의 테스트를 통과한 변경들을 모아서 그중 대표 변경을 하나 뽑는다. 이 변경의 이름이 바로 '열차(The Train)'이다.
  3. 변경들에 직접 영향받는 테스트들을 모두 실행한다. 일정 이상 큰, 혹은 저수준의 LSC인 경우, 이때 구글 리포지터리의 모든 테스트가 실행된다. 그래서 이 단계는 여섯 시간 이상 걸리기도 한다.
  4. 불규칙하지 않으면서 실패한 테스트만 추려 개별 변경에 대해 독립적으로 다시 수행한다. 열차에 올라탄 변경 중 어느 것이 실패의 원흉인지를 알아내는 단계이다.
  5. TAP이 열차에 탑승한 각 변경에 대한 보고서를 생성한다. 보고서에는 성공한 대상과 실패한 대상이 모두 포함되어 있어서 LSC가 서브밋해도 안전한지 판단하는 근거로 활용된다.

### 22.3.6 코드 리뷰

- 모든 변경은 서브밋하기 전에 리뷰를 거쳐야 한다. LSC도 예외가 아니다.
- LSC를 별도의 샤드(shard; 조각)로 나누면 훨씬 쉬워진다.

## 22.4 대규모 변경 인프라

- 구글은 LSC를 위해 인프라에 막대한 투자를 했다. 이 인프라에는 변경 생성, 변경 관리, 변경 리뷰, 테스트 도구 등이 포함된다.
- 도구들보다 중요한 요인은 대규모 변경과 이를 감독하는 프로세스를 둘러싼 문화적 규범의 진화였다.

### 22.4.1 정책과 문화

- 구글은 수많은 소스 코드를 하나의 리포지터리(모노리포)에 보관하며 모든 엔지니어가 그 안의 코드 대부분을 볼 수 있다.
- 이로 인해 누구라도 다른 프로젝트 파일을 수정한 후 승인 권한자에게 검토를 요청할 수 있다. 하지만 그럴 때마다 변경하는 비용과 리뷰 비용이 발생한다.
- 구글은 LSC를 만들려는 팀과 개인을 위한 가벼운 승인 프로세스를 고안했다.
  - 다양한 언어의 미묘한 특성에 익숙한 숙련된 엔지니어 그룹이 감독하며, 이때 새로 만들려는 LSC 관련 도메인에 전문가를 초대한다.
  - 프로세스의 목표는 LSC를 막는 게 아니다. 오히려 변경 작성자가 구글의 기술과 인적 지원을 최대한 활용하여 가장 이상적인 변경을 생성하도록 돕는 것이다.
- 때로는 LSC에 영향받는 개별 팀의 소유자가 특정 커밋에 대해 댓글로 질문을 던질 수 있다. 그러면 보통의 리뷰 때와 마찬가지로 변경 작성자가 답변을 달아준다.

### 22.4.2 코드베이스 인사이트

- LSC를 진행하려면 코드베이스 전반을 분석할 수 있어야 한다. 텍스트 기반의 전통적인 분석은 물론 의미를 추적하는 분석도 중요하다.
- 어떤 도구로 변경을 생성하든 인력 투입량이 코드베이스보다 느리게 커져야 한다. 달리 말하면 리포지터리가 커져도 사람이 개입하는 시간은 크게 달라지지 않아야 한다.
- 도구에 투자하는 비용은 지금 당장에도, 또 앞으로도 결실을 맺어 되돌아온다. 수정해야 하는 코드가 500곳이 넘어가면 사람이 일일이 수정하기보다는 변경 생성 도구를 익혀 이용하는게 효율이 좋았다. 숙련된 코드 관리자라면 훨씬 적은 수정도 도구를 이용하는 편이 낫다.

### 22.4.3 변경 관리

- 대규모 변경 인프라에서 가장 중요한 도구는 마스터 변경을 여러 개의 샤드로 나눈 후 테스트, 메일링, 리뷰, 커밋 단계를 독립적으로 관리해주는 도구이다.
- 구글은 Rosie라는 도구를 사용한다. Rosie를 이용하면 광범위한 변경에 수반되는 수많은 변경을 독립적으로 테스트, 리뷰, 서브밋할 수 있는 작은 샤드들로 나눌 수 있다.

### 22.4.4 테스트

- 테스트는 소프트웨어가 기대한 대로 동작함을 검증하는 중요한 수단이다.
- 사람이 작성하지 않은 변경을 적용하려 할 때 특히 중요하다.
- 건실한 테스트 문화와 인프라가 갖춰져 있다면 도구가 생성한 변경이 의외의 부작용을 일으키지 않을 것임을 더 강하게 확신할 수 있다.
- 구글의 LSC는 다른 변경과 똑같은 CI 인프라를 활용하지만 테스트 전략은 조금 다르게 가져간다. LSC 테스트는 마스터 변경이 문제를 일으키지 않음을 확인하는 일 외에, 개별 샤드를 안전하고 독립적으로 서브밋할 수 있는지까지 검증해야 한다.
- 개별 샤드에는 임의의 파일이 포함될 수 있으므로 표준적인 프로젝트별 프리서브밋 테스트를 이용하지 않는다. 대신 각 샤드에 영향받는 테스트들을 추적하여 수행하는 방식을 활용한다.

### 22.4.5 언어 지원

- 구글은 LSC를 주로 언어별로 진행하며, 언어에 따라 LSC 난이도가 크게 다르다.
  - 타입 별칭과 전달 함수를 지원하는 프로그래밍 언어라면 새로운 시스템으로 마이그레이션하는 중에도 기존 코드가 문제없이 동작하게 만들기가 훨씬 쉽다.
- 정적 타입 언어가 동적 타입 언어보다 훨씬 유리하다. 강력한 정적 분석과 컴파일러 기반 도구가 제공하는 상당한 양의 정보를 도구 제작에 활용하면 문제를 일으키는 변경을 테스트 단계까지 가기 전에 걸러낼 수 있다.
- 어떤 언어를 선택할지는 여러 측면에서 코드 수명과 관련이 깊다. 개발자 생산성에 치중하는 언어일수록 유지보수가 더 어려워진다.
- 자동 포맷터 역시 LSC 인프라에서 중요한 역할을 담당한다. 구글의 모든 LSC 생성 도구가 언어별 자동 포맷터까지 실행해준다.
