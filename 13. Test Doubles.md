# 13. 테스트 대역

- 테스트 대역(test double)은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다.

## 13.1 테스트 대역이 소프트웨어 개발에 미치는 영향

- 테스트 대역을 사용하면 소프트웨어 개발 시 절충이 필요한 복잡한 문제가 몇 가지 딸려 온다.

#### 테스트 용이성(testability)

- 테스트 대역을 사용하려면 코드베이스가 테스트하기 쉽도록 설계되어 있어야 한다.

#### 적용 가능성(applicability)

- 테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선되겠지만, 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락한다.
- 실제로 테스트 대역을 활용하기에 적절하지 않은 경우가 많으니 되도록 실제 구현을 이용하길 권장한다.

#### 충실성(fidelity)

- 충실성은 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말한다.
- 대역이 입력 데이터를 무시하고 항상 똑같은 결과만 반환한다면 그리 유용하지 못할 것이다. 한편 100% 충실한 것 역시 현실적이지 않다. 테스트에 활용하려면 대역은 일반적으로 실제보다 훨씬 단순해야 한다.
- 테스트 대역을 사용하는 단위 테스트들만으로 채우지 못하는 부분은 실제 구현을 이용하는 더 큰 범위의 테스트로 보완해줘야 한다.

## 13.2 테스트 대역 @구글

- 테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다.
- 오늘날에는 많은 엔지니어가 모의 객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성한다.
- 몇 가지의 관행들이 구글 전반에서 받아들여지고 있지만 실제 어떻게 적용되는지는 팀마다 다르다.
  1. 모든 엔지니어가 이 관행들에 익숙하지는 않다.
  2. 기존 코드베이스가 관행을 따르기에 적합하지 않게 작성되어 있기도 하다.
  3. 어떤 팀은 장기적인 영향을 생각하지 않고 단기적으로 가장 쉬운 방법을 택하기도 한다.

## 13.3 기본 개념

### 13.3.1 테스트 대역 예

```swift
// 신용카드 서비스
class PaymentProcessor {
    private let creditCardService: CreditCardService
    
    init(creditCardService: CreditCardService) {
        self.creditCardService = creditCardService
    }
    
    func makePayment(creditCard: CreditCard, amount: Money) -> Bool {
        guard !creditCard.isExpired else { return false }
        return creditCardService.chargeCreditCard(creditCard, amount) 
    }
}

// 기초적인 테스트 대역
class TestDoubleCreditCardService: CreditCardService {
    func chargeCreditCard(_ creditCard: CreditCard, amount: Money) {
        return true
    }
}

// 테스트 대역 적용
func testCardIsExpired_returnFalse() {
    let result = paymentProcessor.makePayment(expiredCard, amount)
    XCTAssertFalse(result)
}
```

### 13.3.2 이어주기

- 단위 테스트를 고려해 짜인 코드를 우리는 테스트하기 쉽다(testable)라고 말한다. 그리고 이어주기(seam)란 제품 코드 차원에서 테스트 대영을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻한다. 프로덕션 환경에서 이용하는 의존 대상을 다른 대상으로 교체할 수 있도록 해주면 된다.
- 대표적인 이어주기 기술로는 의존성 주입(dependency injection, DI)이 있다. 의존성 주입을 활용하는 클래스는 필요한 클래스(의존성)를 내부에서 직접 생성하지 않고 외부에서 건네받는다.

```swift
// 의존성 주입
class PaymentProcessor {
    private let creditCardService: CreditCardService
    
    init(creditCardService: CreditCardService) {
        self.creditCardService = creditCardService
    }
    
    func makePayment(creditCard: CreditCard, amount: Money) -> Bool {
        guard !creditCard.isExpired else { return false }
        return creditCardService.chargeCreditCard(creditCard, amount) 
    }
}
```

- 적절한 `CreditCardService` 인스턴스를 생성할 책임은 생성자를 호출하는 측에 주어진다. 제품 코드에서는 외부 서버와 통신하는 `CreditCardService` 구현을 건네겠지만, 테스트에서는 테스트 대역을 넘길 수 있게 된다.

```swift
// 테스트 대역 건네기
let paymentProcessor = PaymentProcessor(creditCardService: TestDoubleCreditCardService())
```

- 나아가 의존성 주입 프레임워크를 이용하면 테스트 작성자가 생성자를 직접 지정하는 수고를 덜 수 있다.
- 파이썬과 자바스크립트 같은 동적 타입 언어에서는 개별 함수나 메서드를 동적으로 교체할 수 있다. 이런 언어에서는 의존성 주입의 중요도가 낮다. 이 능력을 활용하면 실제 구현 중에서 당장 활용할 수 없는 함수나 메서드만 테스트가 덮어쓸 수 있기 때문이다.

### 13.3.3 모의 객체 프레임워크

- 모의 객체 프레임워크(Mocking framework)는 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리이다. 여기서 모의 객체(mock)는 구체적인 동작 방식을 테스트가 지정할 수 잇는 테스트 대역을 말한다.
- 모의 객체 프레임워크를 사용하면 테스트 대역이 필요할 때마다 새로운 클래스를 정의하지 않아도 되므로 보일러플레이트 코드를 줄일 수 있다.
- Swift는 보안상의 이유로 readwrite reflection을 허용하지 않으므로 모의 객체 프레임워크가 없다(write your own mocks).

```java
// 모의 객체 프레임워크(Mockito)
class PaymentProcessorTest {
  ...
  PaymentProcessor paymentProcessor;

  // 한 줄로 CreditCardService의 테스트 대역을 생성
  @Mock CreditCardService mockCreditCardService;
  @Before public void setUp() {
    // 대상 시스템에 테스트 대역을 건넴
    paymentProcessor = new PaymentProcessor(mockCreditCardService);
  }
  @Test public void chargeCreditCardFails_returnFalse() {
    // 테스트 대역에 특정한 행위를 지시함: 정확하게는 cahrgeCreditCard() 메서드를
    // 호출하면 무조건 false를 반환하도록 했다. 메서드 인수로 any()를 지정했는데,
    // 이는 입력으로 무엇이 들어오든 상관하지 말라는 의미이다.
    when(mockCreditCardService.chargeCreditCard(any(), any())
       .thenReturn(false);
    boolean success = paymentProcessor.makePayment(CREDIT_CARD, AMOUNT);
    assertThat(success).isFalse();
  }  
}
```

- 모의 객체 프레임워크 덕분에 테스트 대역을 손쉽게 사용할 수 있지만 과용하면 코드베이스를 유지보수하기 어렵게 된다는 게 심각한 부작용이다.

## 13.4 테스트 대역 활용 기법

### 13.4.1 속이기(가짜 객체)

- 가짜 객체(fake object)는 제품 코드로는 적합하지 않지만 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역이다. 인메모리 데이터베이스가 좋은 예이다.

```swift
// 간단한 가짜 객체
// 가짜 객체는 빠르고 쉽게 만들 수 있다.
let fakeAuthorizationService = AuthorizationService()
let accessManager = AccessManager(authorizationService: fakeAuthorizationService)

// 모르는 사용자의 ID로는 접근을 불허한다.
XCTAssertFalse(accessManager.userHasAccess(userID)

// 사용자 ID를 인증 서비스에 등록한 다음에는 접근을 허용한다.
fakeAuthorizationService.addAuthorizedUser(User(id: userID))
XCTAssertTrue(accessManager.userHasAccess(userID))
```

- 적절한 가짜 객체가 아직 없다면 새로 작성해야 하는데, 실제 객체의 현재는 물론 미래의 행위까지도 비슷하게 흉내 내야 하기 때문에 결코 쉽지 않다.

### 13.4.2 뭉개기(스텁)

- 스텁(stub)은 원래 없던 행위를 부여하는 과정을 말한다. 예컨대 대상 함수가 반환할 값을 지정한다고 하면, 이를 '반환값을 뭉갠다(스텁한다)'라고 한다.

```swift
// 인증된 사용자가 아닌 경우
let stubAuthorizationService = StubAuthorizationService() 
let accessManager = AccessManager(authorizationService: stubAuthorizationService)

XCTAssertFalse(accessManager.userHasAccess(userID))

// 인증된 사용자인 경우
let stubAuthorizationService = StubAuthorizationService(authorizedUser: User(id: userID))
let accessManager = AccessManager(authorizationService: stubAuthorizationService)

XCTAssertTrue(accessManager.userHasAccess(userID))
```

- Stub은 보통 모의 객체 프레임워크를 이용해 수행한다. 만약 모의 객체 프레임워크가 없었다면 원하는 값을 반환하도록 하드코딩한 클래스들을 직접 생성해야 한다.

### 13.4.3 상호작용 테스트하기

- 상호작용 테스트(interaction test)란 대상 함수를 실제로 호출하지 않고도 그 함수가 어떻게 호출되는지를 검증하는 기법이다. 함수가 올바른 방식으로 호출되지 않으면 실패하는 테스트가 있을 수 있다. 예를 들어 함수가 전혀 호출되지 않거나, 너무 많이 호출되거나, 잘못된 인수와 함께 호출된다면 실패해야 하는 경우.

```swift
let expectedLookupUserResult = (callCount: 1, userID: userID)
let spyAuthorizationService = SpyAuthorizationService()
let accessManager = AccessManager(authorizationService: spyAuthorizationService)

XCTAssertEqual(spyAuthorizationService.lookupResult.callCount, expectedLookupUserResult.callCount)
XCTAssertEqual(spyAuthorizationService.lookupResult.userID, expectedLookupUserResult.userID)
```

- 모의 객체 프레임워크가 없다면 함수가 몇 번 호출되고 어떤 인수를 받았는지를 추적하는 새로운 클래스를 직접 작성해야 한다.
- 상호작용 테스트가 유용한 상황도 있지만 과용하면 테스트들이 깨지기 쉽게 변할 수 있으니 되도록 사용하지 않는게 좋다.

## 13.5 실제 구현

- 구글은 가능하다면 대상 시스템이 의존하는 실제 구현을 사용한다.
- 코드가 프로덕션 환경에서와 동일하게 동작해야 테스트 충실성이 높아지는데, 실제 구현을 이용하면 자연스럽게 그렇게 된다.
- 실제 구현을 선호하는 테스트 방식을 고전적 테스트(classical test)라고 하며, 반대로 모의 객체 프레임워크를 선호하는 테스트 방식은 모의 객체 중심주의 테스트(mockist test)라 한다.
- 모의 객체 중심주의에서는 엔지니어들이 대상 시스템을 엄격한 지침에 따라 설계해야 한다 ([Mock Roles, not Objects](http://jmock.org/oopsla2004.pdf) ).
- 구글의 엔지니어 대부분은 고전적인 테스트에 더 적합한 방식으로 코드를 작성해왔다.

### 13.5.1 격리보다 현실성을 우선하자

- 단위 테스트들이 테스트 대역에 너무 의존한다면 엔지니어가 통합 테스트를 추가로 수행해보거나 수동으로 직접 동작시켜봐야 같은 수준의 확신이 생길 것이다.
- 클래스가 사용하는 모든 의존성을 테스트 대역으로 대체한다는 것은 대상 시스템을 테스트 작성자가 임의로 제공한 구현들로 에워싼다는 뜻이다. 하지만 좋은 테스트라면 어떤 구현을 사용하든 상관없어야 한다.
- 좋은 테스트는 구현이 어떻게 구성되었느냐의 관점이 아니라 검사할 API를 중심으로 작성되어야 한다.

### 13.5.2 실제 구현을 사용할지 결정하기

- 빠르고 결정적이고 의존성 구조가 간단하다면 실제 구현을 사용하는 게 좋다. 예컨대 값 객체(value object)라면 실제 구현을 사용해야 한다.

#### 실행 시간(Execution time)

- 실제 구현의 수행 시간이 오래 걸릴 때는 테스트 대역이 유용할 수 있다. 느린 것의 기준은 판단하기 나름이며, 애매할 때는 실제 구현을 사용하는 것이 좋다. 사용하다 생산성이 떨어지면 테스트 대역을 투입하면 된다.
- 테스트 병렬화도 실행 시간을 줄이는 데 효과적이다.
- 실제 구현을 사용하면 빌드도 오래 걸린다. 테스트를 위해 실제 구현은 물론 그 구현이 참조하는 코드들까지 빌드해야 하기 때문이다.
- 빌드 도구인 Bazel은 변경되지 않은 코드는 이전 빌드 결과를 캐시해주는데, 이처럼 확장성이 뛰어난 빌드 시스템을 이용하면 도움이 된다.

#### 결정성(Determinism)

- 같은 버전의 시스템을 대상으로 실행하면 언제든 똑같은 결과를 내어주는 테스트를 결정적(deterministic)인 테스트라고 한다. 항상 성공하거나 항상 같은 이유로 실패해야 한다는 뜻이다.
- 반대로 대상 시스템은 그대로인데 결과가 달라지는 테스트를 비결정적(nondeterministic)이라 한다.
- 테스트에서 비결정성은 불규칙한 결과로 이어진다. 대상 시스템이 변치 않았음에도 이따금 실패할 수 있다.
- 실제 구현을 사용해도 결과가 거의 일정하다면 엔지니어들에게 크게 방해되지 않겠지만, 결과가 자주 튄다면 테스트 대역 투입을 고려할 때가 온 것이다.
- 밀폐되지 않은, 즉 테스트가 통제할 수 없는 외부 서비스에 의존하는 코드는 비결정성의 주범으로 꼽힌다. 예컨대 HTTP 서버로부터 웹페이지를 읽어 내용을 확인하는 테스트는 서버가 과부하 상태이거나 웹 페이지의 내용이 변하면 실패할 것이다. 이럴 때 테스트 대역을 사용하면 외부 서버에 더 이상 의존하지 않게 할 수 있다.
- 대역을 사용하지 못하는 상황이라면 서버의 밀폐된 인스턴스, 즉 테스트가 생애주기를 통제할 수 있는 인스턴스를 이용하는 대안도 있다.
- 시스템 클록을 읽어 계산에 반영하는 코드도 비결정성의 흔한 예이다. 이럴 때는 시스템 클록 대신 특정 시간이 하드코딩된 테스트 대역을 이용하면 좋다.

#### 의존성 생성(Dependency construction)

- 실제 구현을 이용하려면 의존 대상들도 모두 생성해야 한다. 예컨대 객체를 하나 생성하려면 의존성 트리에 등장하는 모든 객체가 필요하다. 이에 반해 테스트 대역은 대체로 다른 객체를 별로 사용하지 않아 생성하기가 훨씬 쉽다.

```swift
let foo = Foo(a: A(b: B(c: C())), e: E(), ..., z: Z())
```

- 위와 같은 객체가 있다면 각각을 생성하는 방법을 결정하는 데만도 시간이 꽤 걸릴 것이다. 설상가상으로 이 객체들 중 단 하나의 생성자 시그니처만 바뀌어도 테스트까지 함께 수정해야 한다.
- Mockito 모의 객체 프레임워크를 이용한다면 한 줄로 대역을 생성할 수 있다.

```java
@Mock Foo mockFoo;
```

- 제품 코드가 팩터리 메서드나 자동 의존성 주입을 지원한다면 테스트에서도 똑같이 이용하는게 가장 좋다. 이처럼 객체 생성 코드를 테스트에서도 이용할 수 있게 하려면 제품 코드 자체만 생각하여 하드코딩하지 말고, 대역으로 대체할 수 있도록 미리부터 유연하게 만들어놔야 한다.
