# 13. 테스트 대역

- 테스트 대역(test double)은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다.

## 13.1 테스트 대역이 소프트웨어 개발에 미치는 영향

- 테스트 대역을 사용하면 소프트웨어 개발 시 절충이 필요한 복잡한 문제가 몇 가지 딸려 온다.

#### 테스트 용이성(testability)

- 테스트 대역을 사용하려면 코드베이스가 테스트하기 쉽도록 설계되어 있어야 한다.

#### 적용 가능성(applicability)

- 테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선되겠지만, 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락한다.
- 실제로 테스트 대역을 활용하기에 적절하지 않은 경우가 많으니 되도록 실제 구현을 이용하길 권장한다.

#### 충실성(fidelity)

- 충실성은 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말한다.
- 대역이 입력 데이터를 무시하고 항상 똑같은 결과만 반환한다면 그리 유용하지 못할 것이다. 한편 100% 충실한 것 역시 현실적이지 않다. 테스트에 활용하려면 대역은 일반적으로 실제보다 훨씬 단순해야 한다.
- 테스트 대역을 사용하는 단위 테스트들만으로 채우지 못하는 부분은 실제 구현을 이용하는 더 큰 범위의 테스트로 보완해줘야 한다.

## 13.2 테스트 대역 @구글

- 테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다.
- 오늘날에는 많은 엔지니어가 모의 객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성한다.
- 몇 가지의 관행들이 구글 전반에서 받아들여지고 있지만 실제 어떻게 적용되는지는 팀마다 다르다.
  1. 모든 엔지니어가 이 관행들에 익숙하지는 않다.
  2. 기존 코드베이스가 관행을 따르기에 적합하지 않게 작성되어 있기도 하다.
  3. 어떤 팀은 장기적인 영향을 생각하지 않고 단기적으로 가장 쉬운 방법을 택하기도 한다.

## 13.3 기본 개념

### 13.3.1 테스트 대역 예

```swift
// 신용카드 서비스
class PaymentProcessor {
    private let creditCardService: CreditCardService
    
    init(creditCardService: CreditCardService) {
        self.creditCardService = creditCardService
    }
    
    func makePayment(creditCard: CreditCard, amount: Money) -> Bool {
        guard !creditCard.isExpired else { return false }
        return creditCardService.chargeCreditCard(creditCard, amount) 
    }
}

// 기초적인 테스트 대역
class TestDoubleCreditCardService: CreditCardService {
    func chargeCreditCard(_ creditCard: CreditCard, amount: Money) {
        return true
    }
}

// 테스트 대역 적용
func testCardIsExpired_returnFalse() {
    let result = paymentProcessor.makePayment(expiredCard, amount)
    XCTAssertFalse(result)
}
```

### 13.3.2 이어주기

- 단위 테스트를 고려해 짜인 코드를 우리는 테스트하기 쉽다(testable)라고 말한다. 그리고 이어주기(seam)란 제품 코드 차원에서 테스트 대영을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻한다. 프로덕션 환경에서 이용하는 의존 대상을 다른 대상으로 교체할 수 있도록 해주면 된다.
- 대표적인 이어주기 기술로는 의존성 주입(dependency injection, DI)이 있다. 의존성 주입을 활용하는 클래스는 필요한 클래스(의존성)를 내부에서 직접 생성하지 않고 외부에서 건네받는다.

```swift
// 의존성 주입
class PaymentProcessor {
    private let creditCardService: CreditCardService
    
    init(creditCardService: CreditCardService) {
        self.creditCardService = creditCardService
    }
    
    func makePayment(creditCard: CreditCard, amount: Money) -> Bool {
        guard !creditCard.isExpired else { return false }
        return creditCardService.chargeCreditCard(creditCard, amount) 
    }
}
```

- 적절한 `CreditCardService` 인스턴스를 생성할 책임은 생성자를 호출하는 측에 주어진다. 제품 코드에서는 외부 서버와 통신하는 `CreditCardService` 구현을 건네겠지만, 테스트에서는 테스트 대역을 넘길 수 있게 된다.

```swift
// 테스트 대역 건네기
let paymentProcessor = PaymentProcessor(creditCardService: TestDoubleCreditCardService())
```

- 나아가 의존성 주입 프레임워크를 이용하면 테스트 작성자가 생성자를 직접 지정하는 수고를 덜 수 있다.
- 파이썬과 자바스크립트 같은 동적 타입 언어에서는 개별 함수나 메서드를 동적으로 교체할 수 있다. 이런 언어에서는 의존성 주입의 중요도가 낮다. 이 능력을 활용하면 실제 구현 중에서 당장 활용할 수 없는 함수나 메서드만 테스트가 덮어쓸 수 있기 때문이다.

### 13.3.3 모의 객체 프레임워크

- 모의 객체 프레임워크(Mocking framework)는 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리이다. 여기서 모의 객체(mock)는 구체적인 동작 방식을 테스트가 지정할 수 잇는 테스트 대역을 말한다.
- 모의 객체 프레임워크를 사용하면 테스트 대역이 필요할 때마다 새로운 클래스를 정의하지 않아도 되므로 보일러플레이트 코드를 줄일 수 있다.
- Swift는 보안상의 이유로 readwrite reflection을 허용하지 않으므로 모의 객체 프레임워크가 없다(write your own mocks).

```java
// 모의 객체 프레임워크(Mockito)
class PaymentProcessorTest {
  ...
  PaymentProcessor paymentProcessor;

  // 한 줄로 CreditCardService의 테스트 대역을 생성
  @Mock CreditCardService mockCreditCardService;
  @Before public void setUp() {
    // 대상 시스템에 테스트 대역을 건넴
    paymentProcessor = new PaymentProcessor(mockCreditCardService);
  }
  @Test public void chargeCreditCardFails_returnFalse() {
    // 테스트 대역에 특정한 행위를 지시함: 정확하게는 cahrgeCreditCard() 메서드를
    // 호출하면 무조건 false를 반환하도록 했다. 메서드 인수로 any()를 지정했는데,
    // 이는 입력으로 무엇이 들어오든 상관하지 말라는 의미이다.
    when(mockCreditCardService.chargeCreditCard(any(), any())
       .thenReturn(false);
    boolean success = paymentProcessor.makePayment(CREDIT_CARD, AMOUNT);
    assertThat(success).isFalse();
  }  
}
```

- 모의 객체 프레임워크 덕분에 테스트 대역을 손쉽게 사용할 수 있지만 과용하면 코드베이스를 유지보수하기 어렵게 된다는 게 심각한 부작용이다.
