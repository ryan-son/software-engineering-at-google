# 11. 테스트 개요

- 자동 테스트(automated test)는 버그가 몰래 숨어들어 고객을 놀라게 하는 사태를 막아준다.
- 개발 주기에서 버그를 발견하는 시기가 늦어질수록 고치는 비용이 커진다.
- 새로운 기능을 추가하거나, 코드가 더 건실해지도록 리팩터링하거나, 대규모 재설계를 진행하는 상황에서 자동 테스트는 실수를 빠르게 잡아주므로 안심하고 소프트웨어를 변경할 수 있게 해준다.
- 테스트 체계가 잘 갖춰져 있다면 변화를 두려워할 이유가 없다.
- 테스트를 작성하는 행위가 시스템의 설계도 개선해준다. 데이터베이스에 너무 강하게 묶여 있는지, 이 API가 필수 유스케이스를 지원하는지, 시스템이 극단적인 상황들에 잘 대처하는지 등을 확인할 수 있다.
- 자동 테스트를 작성하면 이런 문제들을 개발 주기의 초반에 잡아내게 된다. 그 결과 모듈화가 더 잘되어 미래의 변화에 훨씬 유연한 소프트웨어가 만들어진다.

## 11.1 테스트를 작성하는 이유

- '자동 테스트'의 정체는?
  - 테스트하려는 단 하나의 행위(주로 메서드나 API)
  - 특정한 입력(API에 전달하려는 값)
  - 관측 가능한 출력 혹은 동작
  - 통제된 조건(하나의 격리된 프로세스 등)
- 시스템에 특정 값을 입력하고, 출력 결과를 확인하여 시스템이 기대한 대로 동작한 것인지를 판단한다.
- 코드베이스의 덩치에 비례하여 테스트 스위트도 커진다. 그 과정에서 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이러한 문제를 해결하지 못하면 테스트 스위트의 존폐가 위태로워진다.
- 테스트가 생산성을 떨어뜨리고 고칠 게 계속 나오거나 결과를 믿을 수 없다면 엔지니어들은 더 이상 테스트를 신뢰하지 않고 우회 방법을 찾으려 할 것이다.
- 테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 우리 삶에서 중요한 제품과 서비스의 안전을 보장하는 데도 점점 핵심적인 역할을 하고 있다. 소프트웨어 결함은 단순히 짜증을 일으키는 수준을 넘어서 막대한 금전적 손실을 낳고 심하면 목숨을 앗아가기까지 하기 때문이다.

### 11.1.1 구글 웹 서버 이야기

- 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안 된다.
- 개별 엔지니어가 버그를 심는 빈도는 아주 낮더라도 프로젝트가 커져 팀원이 많아지면 결함 목록은 계속 길어질 것이다.
- 디버깅 방식에서는 버그가 발생할 때마다 엔지니어가 디버거를 실행해 문제를 분석해내야 한다. 자동 테스트와의 엔지니어링 비용 차이는 하늘과 땅만큼 벌어진다.

### 11.1.2 오늘날의 개발 속도에 맞는 테스트

- 대부분의 소프트웨어는 기능과 지원 플랫폼이 너무 폭증해서 사람이 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다. 그래서 테스트에서의 해법은 '자동화'뿐이다.

### 11.1.3 작성하고, 수행하고, 조치하라

- 가장 순수한 형태의 자동 테스트는 '테스트 작성', '테스트 수행', '실패한 테스트에 대한 조치'로 이루어진다.

```swift
// Calculator 클래스가 결과가 음수인 계산을 제대로 처리하는지 확인한다.

func test_2에서5를빼면_마이너스3이다() {
    let sut = Calculator()
    let expectedResult = -3
    
    let actualResult = calculator.subtract(2, 5)
    
    XCTAssertEqual(actualResult, expectedResult)
}
```

- 오늘날 시스템의 규모와 배포 속도를 따라잡으려면 모든 엔지니어가 테스트도 함께 개발해야만 한다.
- 테스트를 작성하는 것과 좋은 테스트를 작성하는 것은 별개이다.
- 테스트를 코드로 작성하면 다양한 환경에서 수행할 수 있도록 테스트들을 모듈화하기도 좋다.
- 실패하는 테스트가 해결되지 못하고 빠르게 쌓여간다면 테스트에 투자한 노력이 허사가 되니 그렇게 되지 않도록 하는 것이 중요하다.
- 건실한 자동 테스트 문화에서는 모두가 테스트를 작성하고 공유하도록 장려하고, 테스트들을 정기적으로 실행한다. 그리고 테스트가 실패하면 바로 조치하도록 권장해야 테스트 프로세스를 신뢰하고 계속 이어갈 수 있다.

### 11.1.4 테스트 코드가 주는 혜택

- 테스트에 투자하는 게 개발자 생산성을 향상시키는 이유는?

#### 디버깅 감소

- 테스트를 거친 후 제출되는 코드는 통상적으로 결함이 적다. 그러므로 그 코드의 존속 기간 전체로 봤을 때 결함이 줄어든다.
- 코드 조각은 수명이 다하는 날까지 여러 팀 또는 자동 코드 유지보수 시스템이 수정할 수도 있다. 그래서 테스트를 한 번 작성해두면 프로젝트가 살아 있는 내내 값비싼 결함을 예방해주고 짜증나는 디버깅에서 해방시켜주는 식으로 지속해서 혜택을 준다.

#### 자신 있게 변경

- 테스트들이 프롲게트의 주요 기능들을 끊임없이 검증해주는 덕에 좋은 테스트들로 무장한 팀은 자신감을 가지고 변경들을 리뷰하고 수용할 수 있다.
- 행위가 달라지지 않는 리팩터링 시에는 테스트 자체는 변경될 필요가 없으므로 적극 권장할 수 있다.

#### 더 나은 문서자료

- 한 번에 하나의 행위만 집중해 검증하는 명확한 테스트는 마치 실행 가능한 문서와 같다. 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 되기 때문이다.
- 요구사항이 변경되어 새로운 코드가 기존 테스트를 통과하지 못한다면 그 문서자료(테스트)가 이제 낡았음을 알 수 있다.

#### 더 단순한 리뷰

- 정확성, 극단 상황, 오류 상황 등 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지를 검증하는 시간을 크게 줄여준다. 각각의 상황을 머릿속에서 일일이 그려보는 대신 해당 테스트를 수행해 통과하는지만 보면 되기 때문이다.

#### 사려 깊은 설계

- 새로 작성한 코드의 테스트를 작성하는 일은 해당 코드의 API가 잘 설계되었는지를 시험하는 행위이다.
- 테스트하기 어려운 코드는 너무 많은 역할을 짊어지거나 의존성을 관리하기 어렵게 짜여졌기 때문일 가능성이 크다.
- 잘 설계된 코드라면 모듈화가 잘 되어 있어야 한다. 다른 코드와 강하게 결합되지 않고 특정 역할에 집중해야 한다.
- 설계 문제를 조기에 바로잡는다면 훗날 수정할 때 고생을 덜 한다.

#### 고품질의 릴리즈를 빠르게

- 건실한 자동 테스트 스위트를 갖춘 팀은 새로운 버전을 릴리즈하며 불안에 떨지 않는다.
