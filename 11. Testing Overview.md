# 11. 테스트 개요

- 자동 테스트(automated test)는 버그가 몰래 숨어들어 고객을 놀라게 하는 사태를 막아준다.
- 개발 주기에서 버그를 발견하는 시기가 늦어질수록 고치는 비용이 커진다.
- 새로운 기능을 추가하거나, 코드가 더 건실해지도록 리팩터링하거나, 대규모 재설계를 진행하는 상황에서 자동 테스트는 실수를 빠르게 잡아주므로 안심하고 소프트웨어를 변경할 수 있게 해준다.
- 테스트 체계가 잘 갖춰져 있다면 변화를 두려워할 이유가 없다.
- 테스트를 작성하는 행위가 시스템의 설계도 개선해준다. 데이터베이스에 너무 강하게 묶여 있는지, 이 API가 필수 유스케이스를 지원하는지, 시스템이 극단적인 상황들에 잘 대처하는지 등을 확인할 수 있다.
- 자동 테스트를 작성하면 이런 문제들을 개발 주기의 초반에 잡아내게 된다. 그 결과 모듈화가 더 잘되어 미래의 변화에 훨씬 유연한 소프트웨어가 만들어진다.

## 11.1 테스트를 작성하는 이유

- '자동 테스트'의 정체는?
  - 테스트하려는 단 하나의 행위(주로 메서드나 API)
  - 특정한 입력(API에 전달하려는 값)
  - 관측 가능한 출력 혹은 동작
  - 통제된 조건(하나의 격리된 프로세스 등)
- 시스템에 특정 값을 입력하고, 출력 결과를 확인하여 시스템이 기대한 대로 동작한 것인지를 판단한다.
- 코드베이스의 덩치에 비례하여 테스트 스위트도 커진다. 그 과정에서 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이러한 문제를 해결하지 못하면 테스트 스위트의 존폐가 위태로워진다.
- 테스트가 생산성을 떨어뜨리고 고칠 게 계속 나오거나 결과를 믿을 수 없다면 엔지니어들은 더 이상 테스트를 신뢰하지 않고 우회 방법을 찾으려 할 것이다.
- 테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 우리 삶에서 중요한 제품과 서비스의 안전을 보장하는 데도 점점 핵심적인 역할을 하고 있다. 소프트웨어 결함은 단순히 짜증을 일으키는 수준을 넘어서 막대한 금전적 손실을 낳고 심하면 목숨을 앗아가기까지 하기 때문이다.

### 11.1.1 구글 웹 서버 이야기

- 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안 된다.
- 개별 엔지니어가 버그를 심는 빈도는 아주 낮더라도 프로젝트가 커져 팀원이 많아지면 결함 목록은 계속 길어질 것이다.
- 디버깅 방식에서는 버그가 발생할 때마다 엔지니어가 디버거를 실행해 문제를 분석해내야 한다. 자동 테스트와의 엔지니어링 비용 차이는 하늘과 땅만큼 벌어진다.

### 11.1.2 오늘날의 개발 속도에 맞는 테스트

- 대부분의 소프트웨어는 기능과 지원 플랫폼이 너무 폭증해서 사람이 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다. 그래서 테스트에서의 해법은 '자동화'뿐이다.

