# 16. 버전 관리와 브랜치 관리

## 16.1 버전 관리란?

- 파일의 시간에 따른 변경 기록(버전)을 추적하는 시스템
- 파일들의 메타 데이터를 관리하며, 이와 버전별 복사본을 합쳐 리포지터리라고 한다.
- 여러 개발자가 같은 파일들로 동시에 작업할 수 있어서 팀 업무를 효과적으로 조율할 수 있다.
- 합의된 단일 진실 공급원(Single Source of Truth, SSOT)이 없는 환경에서 협업하려면 너무 불편하고 오류가 많이 생겨 도입

### 16.1.1 버전 관리가 중요한 이유

- VCS(파일 이름, 작성 시각, 브랜치 이름) => 파일 내용
- 따로 명시하지 않으면 브랜치는 기본적으로 메인 브랜치를 가리키며, 메인 브랜치를 보통 'head', 'default', 'trunk' 등으로 부른다.

### 16.1.2 중앙집중형 VCS vs 분산형 VCS

#### 중앙집중형 VCS(Centralized VCS)

- 단 하나의 중앙 리포지터리를 이용하는 모델(조직 내 공유 컴퓨트 자원을 이용할 가능성이 큼)
- 개발자들은 각 파일을 체크아웃하여 로컬 컴퓨터에서 이용할 수 있지만, 파일들의 버전 관리 상태와 관련된 작업들(파일 추가, 도익화, 기존 파일 갱신 등)은 반드시 중앙 서버에 전달해야 한다.

#### 분산형 VCS(Distributed VCS)

- 전통적인 중앙집중형 VCS와 개념적으로 가장 큰 차이는 '어디에 커밋하는가?' 혹은 '이 파일들의 어느 복사본이 리포지터리로 간주되는가?'
- 분산형 VCS에서의 작업 흐름
  1. 기존 리포지터리를 로컬에 복제한다.
  2. 파일을 변경한다.
  3. 로컬 리포지터리에 커밋한다.
  4. 2~3을 원하는 만큼 반복한다.
  5. 로컬에 적용된 커밋 중 일부 혹은 전체를 다른 리포지터리로 커밋한다. 이때 다른 리포지터리는 1에서 복제해온 리포지터리일 수도, 아닐 수도 있다.
- 특정한 하나를 진실 공급원이라고 지정하지 않아도 되므로 오프라인 작업과 협업에 더 유리하다.

### 16.1.3 진실 공급원

- 커밋 태그와 PR을 전혀 다른 개발 브랜치로 전달할 수 있기에 회귀할 위험이 존재한다. 따라서 분산형 VCS를 운영하려면 정책과 규범을 더 명확하게 정해 지켜야 한다.

### 16.1.4 버전 관리 vs 의존성 관리

- 버전 관리 정책은 개념적으로 의존성 관리와 매우 비슷하다.
- 의존성 관리는 다른 조직에서 통제하는 프로젝트들을 관리해야 하기에 훨씬 어렵다.

## 16.2 브랜치 관리

### 16.2.1 '진행 중인 작업'은 브랜치 작업과 비슷하다

### 16.2.2 개발 브랜치

- 일관된 단위 테스트가 보편화되기 전 시절에는 작은 변경 하나라도 시스템을 망가뜨릴 위험이 컸기 때문에 트렁크를 특별 취급하는 게 당연했다.
- 개발 브랜치(dev branch)는 '구현은 다 했지만 커밋하진 않았어요'와 '이제부터 이 코드를 기준으로 개발하세요'의 중간 단계이다.
- 제품이 불안정해지는 일은 방지해야 하지만, 테스트, 지속적 통합, 철저한 코드 리뷰와 같은 품질 강화 활동을 더 광범위하게 진행하는 편이 훨씬 효과가 좋다.
- 큰 단위로 한꺼번에 병합하기보다는 작게 작게 자주 병합하는 게 쉽다.
- 거대한 브랜치를 병합할 때는 많은 것이 변경된 상태이므로 문제 원인이라고 예상되는 범위를 좁히기가 어렵다. 문제를 분류하고 근본 원인을 파악해내기 어렵고, 수정하기는 더욱 어렵다.

#### 개발 브랜치에 중독되어 가는 과정

- 오래된 개발 브랜치를 병합하니 안정성이 떨어진다는 경험이 병합은 위험하다라는 결론으로 이어진다. 그래서 더 나은 테스트와 브랜치 기반 개발 전략 탈피로 정면돌파하지 않고 문제와 마주하는 날을 최대한 늦춘다.
- 트렁크 기반 개발을 통해 테스트와 CI를 적극 활용하여 모든 빌드와 테스트가 항상 성공하도록 관리하며, 완벽하지 않거나 테스트되지 않은 기능은 비활성화 한다.
- 엔지니어 개개인이 트렁크와 동기화하고 트렁크에 커밋해야 한다.

### 16.2.3 릴리즈 브랜치

- 제품의 릴리즈 간격(혹은 릴리즈 수명)이 몇 시간 이상이면 릴리즈 브랜치를 따로 생성하는 게 좋다.
- 공식 릴리즈 후 다음 릴리즈 전에 심각한 결함이 발견된다면 트렁크에서 해당 수정 코드를 최소한으로 선별하여 릴리즈 브랜치로 병합한다.
- 트렁크로부터 하루에도 몇 번씩 릴리즈할 수 있는 지속적 배포(Continuous deployment, CD)가 잘 자리 잡은 조직에서는 대체로 릴리즈 브랜치를 건너뛴다. 수정 사항을 적용해 다시 배포하는 게 훨씬 쉽기 때문이다.
- 구글 DORA 조직 연구결과 '트렁크 기반 개발' 조직과 '장기간 유지되는 개발 브랜치가 적은' 조직일수록 기술적 성취가 뛰어나다.

## 16.3 버전 관리 @구글

- 크로미움, 안드로이드 같은 오픈 소스 프로젝트를 제외하고는 모노레포에서 관리된다. 엔지니어는 5만여 명이다.
- 자체 개발한 중앙집중형 VCS인 Piper를 사용하며, 80 TB가 넘는 콘텐츠와 메타 데이터를 담고 있다.
- 소유권을 텍스트 파일로 관리하여 팀 이동이나 조직 개편 결과를 반영하기가 아주 쉽다.

### 16.3.1 원-버전

- 버전 관리의 또 다른 축은 정책이다.
- 구글 버전 관리 정책의 중심에는 원-버전(One-Version)이 있다. 원-버전은 어느 리포지터리의 어느 브랜치가 진실 공급원인지를 개발자가 명확히 알도록 한다는 '단일 진실 공급원' 개념을 확장한 개념이다. 구체적으로는 '모든 의존성이 우리 리포지터리에 담겨 있고 각 의존성은 단 하나의 안정된 버전만 존재해야 한다'는 뜻이다.

### 16.3.2 시나리오: 여러 버전을 허용한다면?

- 원본과 포크 버전을 동시에 의존하게 되면 빌드 실패 또는 이해하기 어려운 런타임 버그가 발생한다.
- 셰이딩 및 관련 기술들은 '동일한 의존성의 여러 버전이 필요하다'라는 근본적인 문제에 천을 덧대는 미봉책에 불과하다.
- 같은 코드베이스에서 여러 개의 버전이 공존하는 걸 허용하는 정책은 모두 값비싼 호환성 문제를 품고 있다. 여러 가지 트릭을 동원하여 잠시 동안은 피할 수 있겠지만 결국은 큰 문제로 이어질 확률이 매우 높다.

### 16.3.3 원-버전 규칙

- 원-버전 규칙: 개발자가 '이 구성 요소는 어떤 버전을 사용해야 하죠?'라고 묻는 상황을 만들지 않는다.
- 의존성을 새로 추가할 때 '선택'할 수 있는 버전을 제한한다.

### 16.3.4 장수 브랜치는 (웬만하면) 금지

- 원-버전 규칙 중 가장 중요한 정책은 개발 브랜치를 되도록 만들지 말고, 만들더라도 매우 짧게 쓰고 없애야 한다는 것이다.
- 커밋하지 않고 계류 중인 작업도 개발 브랜치와 비슷하다. 오래 묵히지 말고 작업을 작은 증분으로 나눠 정기적으로 트렁크에 커밋해야 한다.
- 활발하게 진화 중인 API에 대해서는 함부로 약속해서는 안 되며, 지원 기간도 신중하게 정해야 한다. 그래서 구글의 프로덕션 서비스들은 이런 약속을 잘 안하는 편이다.
- 빌드 호라이즌(Build horizon): 프로덕션 환경에서 구동 중인 모든 제품은 최대 6개월 안에 다시 빌드하여 재배포해야 한다는 정책.

### 16.3.5 릴리즈 브랜치는 어떤가?

- 구글에서는 많은 팀이 릴리즈 브랜치를 이용하고 최소한의 수정만 반영한다.
- 릴리즈 브랜치에 반영할 수정은 신중히 고민하여 최소한으로 선별하고, 다시 트렁크로 병합할 계획은 세우지 않는다.
- 경험상 릴리즈 브랜치가 광범위한 비용을 발생시키지는 않는다.
