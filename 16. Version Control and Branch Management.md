# 16. 버전 관리와 브랜치 관리

## 16.1 버전 관리란?

- 파일의 시간에 따른 변경 기록(버전)을 추적하는 시스템
- 파일들의 메타 데이터를 관리하며, 이와 버전별 복사본을 합쳐 리포지터리라고 한다.
- 여러 개발자가 같은 파일들로 동시에 작업할 수 있어서 팀 업무를 효과적으로 조율할 수 있다.
- 합의된 단일 진실 공급원(Single Source of Truth, SSOT)이 없는 환경에서 협업하려면 너무 불편하고 오류가 많이 생겨 도입

### 16.1.1 버전 관리가 중요한 이유

- VCS(파일 이름, 작성 시각, 브랜치 이름) => 파일 내용
- 따로 명시하지 않으면 브랜치는 기본적으로 메인 브랜치를 가리키며, 메인 브랜치를 보통 'head', 'default', 'trunk' 등으로 부른다.

### 16.1.2 중앙집중형 VCS vs 분산형 VCS

#### 중앙집중형 VCS(Centralized VCS)

- 단 하나의 중앙 리포지터리를 이용하는 모델(조직 내 공유 컴퓨트 자원을 이용할 가능성이 큼)
- 개발자들은 각 파일을 체크아웃하여 로컬 컴퓨터에서 이용할 수 있지만, 파일들의 버전 관리 상태와 관련된 작업들(파일 추가, 도익화, 기존 파일 갱신 등)은 반드시 중앙 서버에 전달해야 한다.

#### 분산형 VCS(Distributed VCS)

- 전통적인 중앙집중형 VCS와 개념적으로 가장 큰 차이는 '어디에 커밋하는가?' 혹은 '이 파일들의 어느 복사본이 리포지터리로 간주되는가?'
- 분산형 VCS에서의 작업 흐름
  1. 기존 리포지터리를 로컬에 복제한다.
  2. 파일을 변경한다.
  3. 로컬 리포지터리에 커밋한다.
  4. 2~3을 원하는 만큼 반복한다.
  5. 로컬에 적용된 커밋 중 일부 혹은 전체를 다른 리포지터리로 커밋한다. 이때 다른 리포지터리는 1에서 복제해온 리포지터리일 수도, 아닐 수도 있다.
- 특정한 하나를 진실 공급원이라고 지정하지 않아도 되므로 오프라인 작업과 협업에 더 유리하다.

### 16.1.3 진실 공급원

- 커밋 태그와 PR을 전혀 다른 개발 브랜치로 전달할 수 있기에 회귀할 위험이 존재한다. 따라서 분산형 VCS를 운영하려면 정책과 규범을 더 명확하게 정해 지켜야 한다.

### 16.1.4 버전 관리 vs 의존성 관리

- 버전 관리 정책은 개념적으로 의존성 관리와 매우 비슷하다.
- 의존성 관리는 다른 조직에서 통제하는 프로젝트들을 관리해야 하기에 훨씬 어렵다.

## 16.2 브랜치 관리

### 16.2.1 '진행 중인 작업'은 브랜치 작업과 비슷하다

### 16.2.2 개발 브랜치

- 일관된 단위 테스트가 보편화되기 전 시절에는 작은 변경 하나라도 시스템을 망가뜨릴 위험이 컸기 때문에 트렁크를 특별 취급하는 게 당연했다.
- 개발 브랜치(dev branch)는 '구현은 다 했지만 커밋하진 않았어요'와 '이제부터 이 코드를 기준으로 개발하세요'의 중간 단계이다.
- 제품이 불안정해지는 일은 방지해야 하지만, 테스트, 지속적 통합, 철저한 코드 리뷰와 같은 품질 강화 활동을 더 광범위하게 진행하는 편이 훨씬 효과가 좋다.
- 큰 단위로 한꺼번에 병합하기보다는 작게 작게 자주 병합하는 게 쉽다.
- 거대한 브랜치를 병합할 때는 많은 것이 변경된 상태이므로 문제 원인이라고 예상되는 범위를 좁히기가 어렵다. 문제를 분류하고 근본 원인을 파악해내기 어렵고, 수정하기는 더욱 어렵다.

#### 개발 브랜치에 중독되어 가는 과정

- 오래된 개발 브랜치를 병합하니 안정성이 떨어진다는 경험이 병합은 위험하다라는 결론으로 이어진다. 그래서 더 나은 테스트와 브랜치 기반 개발 전략 탈피로 정면돌파하지 않고 문제와 마주하는 날을 최대한 늦춘다.
- 트렁크 기반 개발을 통해 테스트와 CI를 적극 활용하여 모든 빌드와 테스트가 항상 성공하도록 관리하며, 완벽하지 않거나 테스트되지 않은 기능은 비활성화 한다.
- 엔지니어 개개인이 트렁크와 동기화하고 트렁크에 커밋해야 한다.

### 16.2.3 릴리즈 브랜치

- 제품의 릴리즈 간격(혹은 릴리즈 수명)이 몇 시간 이상이면 릴리즈 브랜치를 따로 생성하는 게 좋다.
- 공식 릴리즈 후 다음 릴리즈 전에 심각한 결함이 발견된다면 트렁크에서 해당 수정 코드를 최소한으로 선별하여 릴리즈 브랜치로 병합한다.
- 트렁크로부터 하루에도 몇 번씩 릴리즈할 수 있는 지속적 배포(Continuous deployment, CD)가 잘 자리 잡은 조직에서는 대체로 릴리즈 브랜치를 건너뛴다. 수정 사항을 적용해 다시 배포하는 게 훨씬 쉽기 때문이다.
- 구글 DORA 조직 연구결과 '트렁크 기반 개발' 조직과 '장기간 유지되는 개발 브랜치가 적은' 조직일수록 기술적 성취가 뛰어나다.

## 16.3 버전 관리 @구글

- 크로미움, 안드로이드 같은 오픈 소스 프로젝트를 제외하고는 모노레포에서 관리된다. 엔지니어는 5만여 명이다.
- 자체 개발한 중앙집중형 VCS인 Piper를 사용하며, 80 TB가 넘는 콘텐츠와 메타 데이터를 담고 있다.
- 소유권을 텍스트 파일로 관리하여 팀 이동이나 조직 개편 결과를 반영하기가 아주 쉽다.

### 16.3.1 원-버전

- 버전 관리의 또 다른 축은 정책이다.
- 구글 버전 관리 정책의 중심에는 원-버전(One-Version)이 있다. 원-버전은 어느 리포지터리의 어느 브랜치가 진실 공급원인지를 개발자가 명확히 알도록 한다는 '단일 진실 공급원' 개념을 확장한 개념이다. 구체적으로는 '모든 의존성이 우리 리포지터리에 담겨 있고 각 의존성은 단 하나의 안정된 버전만 존재해야 한다'는 뜻이다.

### 16.3.2 시나리오: 여러 버전을 허용한다면?

- 원본과 포크 버전을 동시에 의존하게 되면 빌드 실패 또는 이해하기 어려운 런타임 버그가 발생한다.
- 셰이딩 및 관련 기술들은 '동일한 의존성의 여러 버전이 필요하다'라는 근본적인 문제에 천을 덧대는 미봉책에 불과하다.
- 같은 코드베이스에서 여러 개의 버전이 공존하는 걸 허용하는 정책은 모두 값비싼 호환성 문제를 품고 있다. 여러 가지 트릭을 동원하여 잠시 동안은 피할 수 있겠지만 결국은 큰 문제로 이어질 확률이 매우 높다.

### 16.3.3 원-버전 규칙

- 원-버전 규칙: 개발자가 '이 구성 요소는 어떤 버전을 사용해야 하죠?'라고 묻는 상황을 만들지 않는다.
- 의존성을 새로 추가할 때 '선택'할 수 있는 버전을 제한한다.

### 16.3.4 장수 브랜치는 (웬만하면) 금지

- 원-버전 규칙 중 가장 중요한 정책은 개발 브랜치를 되도록 만들지 말고, 만들더라도 매우 짧게 쓰고 없애야 한다는 것이다.
- 커밋하지 않고 계류 중인 작업도 개발 브랜치와 비슷하다. 오래 묵히지 말고 작업을 작은 증분으로 나눠 정기적으로 트렁크에 커밋해야 한다.
- 활발하게 진화 중인 API에 대해서는 함부로 약속해서는 안 되며, 지원 기간도 신중하게 정해야 한다. 그래서 구글의 프로덕션 서비스들은 이런 약속을 잘 안하는 편이다.
- 빌드 호라이즌(Build horizon): 프로덕션 환경에서 구동 중인 모든 제품은 최대 6개월 안에 다시 빌드하여 재배포해야 한다는 정책.

### 16.3.5 릴리즈 브랜치는 어떤가?

- 구글에서는 많은 팀이 릴리즈 브랜치를 이용하고 최소한의 수정만 반영한다.
- 릴리즈 브랜치에 반영할 수정은 신중히 고민하여 최소한으로 선별하고, 다시 트렁크로 병합할 계획은 세우지 않는다.
- 경험상 릴리즈 브랜치가 광범위한 비용을 발생시키지는 않는다.

## 16.4 모노리포(단일 리포지터리)

- 모노리포 방식은 그 자체로 몇 가지 이점을 제공한다.
  - 원-버전을 고수하기가 쉽다.
  - 일관성 덕분에 도구를 새로 도입하거나 코드를 최적화한 혜택이 조직 전체에 훨씬 빠르게 전파된다.
- 모노리포 방식이 모든 이에게 정답일 수는 없다.
- 중요한 것은 모노리포냐 아니냐가 아니라 원-버전 원칙을 최대한 준수하는 것이다. 즉, 조직에서 이미 사용 중인 라이브러리에 대한 의존성을 추가할 때 개발자가 버전을 하게 해서는 안 된다. 원-버전 규칙에 선택이 끼어들면 필시 병합 전략 논의, 다이아몬드 종속성, 노력 낭비가 뒤따라 온다.
- 개인정보, 법 준수, 비밀 유지, 보안 등의 요구사항이 모든 프로젝트에 동일하게 적용되는 조직이라면 모노리포가 좋다. 그렇지 않다면 모노리포라는 이상을 추구하되 같은 경험을 다른 방식으로 구현해내는 방법을 알아보는 것이 좋다.
- 결국은 어떤 파일 시스템을 선택하느냐보다 그 안에 무엇을 담느냐가 더 중요하다.

## 16.5 버전 관리의 미래

- 모노리포에 대한 가장 큰 우려는 모든 것을 하나의 리포지터리에 담을 수 있는 기술이 있느냐는 것이다.
- Git에는 얕은 복제(shallow clone), 희소 브랜치(sparse branch), 최적화 등 대규모 리포지터리를 지원하는 기능이 다수 갖춰졌다. 이대로 간다면 리포지터리를 작게 유지해야 한다는 주장의 힘은 점점 더 약해질 수 있다.
- 멀티리포 방식에서는 개발자 접근 제한, 가시성, 권한 등을 리포지터리별로 다르게 가져가기가 아주 쉽다. 이에 필요한 기능들을 모노리포에도 적용할 수 있겠지만, 그러려면 끊임ㅇ없이 사용자화하고 유지보수해야할 것이다.
- (가상) 모노리포에 원-버전 규칙을 더하면 소프트웨어 개발을 복잡하게 만드는 원흉 중 하나인 시간이라는 요인에서 많이 자유로워진다.
- 버전 관리와 의존성 관리의 향후 방향 예측
  - VCS는 확장성을 개선해 더 큰 리포지터리를 지원한다.
  - 리포지터리들이 프로젝트와 조직 경계를 넘어 더 유연하게 연동되도록 해주는 반대 방향의 기술도 발전시킬 것이다.
  
## 16.6 마치며

- 버전 관리 시스템은 협업 효율을 끌어올리기 위해 업무 조율 정책에 기술을 접목하면서 자연스럽게 탄생될 결과물이다.
- 미래에는 네트워크는 항시 연결되어 있다고 가정하고 클라우드에 저장하고 클라우드에서 빌드하여 불필요한 파일 전송을 줄이는 쪽으로 전개될 것이다.
- 분산 VCS는 설정을 엄격하게 통제하고 각 조직에 맞는 브랜치 관리 정책과 결합될 때 비로소 빛을 발한다.

## 16.7 핵심 정리

- 앞으로 업데이트할 일 없는 개인 토이 프로젝트가 아니라면 소프트웨어 개발 프로젝트에서는 무조건 버전 관리 시스템을 이용한다.
- 어느 버전을 사용할 지 선택할 수 있다면 잠재적으로 확장성이 떨어진다는 뜻이다.
- 원-버전 규칙은 조직의 효율에 지대한 영향을 준다. 어디에 커밋할지 혹은 어느 걸 사용할지 선택할 일을 없애면 일이 단순해진다.
- 어떤 언어에서는 셰이딩, 분리 컴파일, 링커 숨기기 같은 기술로 이 문제를 회피할 수 있지만 노력 낭비이다. 아무것도 생산하지 않으면서 기술 부채만 쌓는 꼴이기 때문이다.
- 기존 연구들이 트렁크 기반으로 개발하는 조직일수록 성과가 좋을 가능성이 높음을 보여줬다. 장수 개발 브랜치는 좋지 않은 계획이다.
- 적합한 버전 관리 시스템을 사용한다. 조직에서 리포지터리를 프로젝트별로 두는 쪽을 선호하더라도 리포지터리 간 의존성을 설정해 어느 하나를 트렁크로 지정해두는 게 유리할 수 있다.
