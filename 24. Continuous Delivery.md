# 24. 지속적 배포

- 제품이 경쟁력을 갖추기 위해서는 시장에 신속하게 출시할 수 있는 능력이 중요하다.
  - 유사 서비스와의 경쟁, 제품과 서비스 품질 유지, 새로운 규제에의 적응에 내 조직의 속도
- 처음부터 완벽한 소프트웨어란 존재하지 않는다. 확실한 건 출시 후 빠르게 업데이트해야 한다는 사실 뿐이다.
- 오랜 기간 성공적으로 살아남은 조직들은 아이디어를 빠르게 실천하고 고객의 손에 최대한 빨리 전달하고 피드백에 신속하게 대응하는 능력을 갖췄다.
- 고객에게 제품을 보여주지 않은 채 진행하는 기간이 길수록 위험과 비용이 커진다. 심지어 개발자의 사기마저 떨어뜨릴 수 있다.
- 코드의 가치는 서브밋 시점이 아니라 고객이 그 기능을 이용할 때 실현된다.
- 코드 완성과 사용자 피드백 사이의 시간을 단축할수록 진행 중인 작업의 비용이 줄어든다.

> 제품 런칭은 절대 끝이 아니다. 내가 지금 어디에 와 있고, 다음에 고쳐야 할 가장 중요한 건 무엇이고, 진행 상황을 측정하고, 그다음 문제를 찾아 수정하는 학습주기가 시작됐을 뿐이다. 절대 끝은 없다. 이 사실을 깨닫는다면 위대한 성취를 이루게 될 것이다. - 에비이드 위클리, 전 구글 제품 매니저

## 24.1 지속적 배포 이디엄 @구글

- 지속적 배포(Continuous Delivery, CD) 그리고 애자일 방법론의 핵심 교리는 작은 변경들을 자주 배포할수록 품질이 높아진다는 것이다. '빠를수록 안전하다(faster is safer)'는 말이다.
- CD라는 최종 목표에 다가가는 과정에서 독립적으로 취할 수 있는 가치들
  - 민첩성: 자주, 작게 릴리즈한다.
  - 자동화: 잦은 릴리스에 수반되는 반복 작업 부담을 줄이거나 없앤다.
  - 격리: 변경을 격리하여 문제를 쉽게 해결할 수 있도록 모듈화된 아키텍처를 지향한다.
  - 신뢰성: 비정상 종료와 지연시간 같은 주요 상태 지표를 측정하고 꾸준히 개선한다.
  - 데이터 중심 의사결정: A/B 실험으로 상태 지표를 비교하여 품질을 높인다.
  - 단계적 출시: 변경을 모두에게 동시에 출시하지 않고 소수의 사용자부터 이용해보게 한다.
- 이상적으로는 두 릴리즈 사이의 변경이 적을수록 문제를 해결하기 쉽다.

## 24.2 속도는 팀 스포츠다: 배포를 관리 가능한 조각으로 나누기

- 팀이 작을 때는 변경들이 일정한 속도로 코드베이스에 도달한다. 하지만 시간이 흘러 팀이 커지거나 하위 팀으로 쪼개지면서 안티패턴이 고개를 든다.
- 릴리즈 비용이 늘고 위험이 커지면 본능적으로 릴리즈 주기를 늦춰 안정성을 확보할 기간을 늘리려 한다. 하지만 이렇게 해서 얻는 안도감은 짧은 기간만 유지될 뿐, 멀리 보면 팀의 속도가 느려지고 팀과 고객을 모두 좌절시키는 선택이다.
- 답은 비용을 줄이고, 규율을 강화하고, 위험에 점진적으로 대응하는 것이다. 
  - 당장의 안정을 위한 프로세스 수정에 저항하고 장기적인 아키텍처 개선에 투자해야 하는 게 핵심이다.
  - 눈앞의 안정만 추구한다면 낡은 개발 프로세스로 회귀하기 쉽다.
- 가장 효과가 좋았던 투자는 마이크로서비스 아키텍처로의 전환이었다.
- 구글의 역사를 보면 종종 제품을 단순히 마이그레이션하는 수준이 아니라 처음부터 다시 짜는 게 올바른 선택이었다. 유튜브는 원하는 수준의 모듈성을 새로운 아키텍처에 녹였다. 수개월이 걸릴 수 있고 단기적으로는 고통스러운 선택이었지만, 운영 비용과 이해하기 쉬워진 코드베이스, 애플리케이션의 긴 수명을 고려해보면 득이 훨씬 많을 것이다.

## 24.3 변경을 격리해 평가하자: 기능 플래그로 보호하기

- 지속적인 릴리증를 안정적으로 수행하는 핵심은 엔지니어들이 모든 변경에 플래그 가드(flag guard)를 넣도록 하는 것이다.
  - 플래그 가드: 플래그를 이용하여 제품의 코드를 기능 단위로 제어(활성화/비활성화)하는 기법
- 제품이 커질수록 서로 다른 개발 단계에 놓인 (성숙된 정도가 다른) 여러 기능이 하나의 바이너리에 공존할 확률이 높아진다. 플래그 가드를 이용해 릴리즈용 빌드, 개발용 빌드를 다르게 설정할 수 있따.
- 바이너리에 이전 기능을 실행하는 코드와 새로운 기능을 실행하는 코드를 모두 넣기도 한다. 새로운 코드가 충분히 준비됐다고 판단되면 다음 릴리즈에서는 이전 기능을 실행하는 코드를 막고 새로운 기능을 데뷔시킨다. 릴리즈 후 문제가 생기면 바이너리 릴리즈 없이 플래그 값만 동적으로 수정할 수 있다.
- 모든 고객의 플래그를 동시에 수정하는 건 좋은 생각이 아니다. 따라서 설정 배포를 안전하게 관리해주는 설정 서비스를 마련해두는 게 좋다.

## 24.4 기민해지기 위한 분투: 릴리즈 열차 갖추기

- 릴리즈 주기를 예측할 수 있도록 하기 위해 선택한 트레이드 오프. 크게 두 가지를 프로세스에 녹여냈다.

### 24.4.1 완벽한 바이너리는 없다

- 완벽한 바이너리는 없음을 인정한다.
- 모든 버그를 수정하는 건 불가능할지라도 다음과 같은 질문을 던지는 걸 멈춰서는 안 된다.
  - 선이 왼쪽으로 2픽셀만큼 이동하면 광고 노출과 잠재 수익에 영향이 있을까?
  - 박스 음영을 살짝 달리해보면 어떨까?
  - 시각 장애인이 읽기 어려워지지는 않을까?
- 프로덕션에 새로운 변경을 리리즈할 때마다 무언가를 결정하고 절충해야 한다.
  - 핵심 성과 지표(Key Performance Indicator, KPI)와 명확한 문턱값을 활용하면 비록 완벽하지는 않더라도 기능을 출시할 수 있다.

### 24.4.2 릴리즈 시한을 지켜라

> 마감일은 확실하지만, 인생은 그렇지 않다.

- 릴리즈 열차 시간에 늦으면 기다리지 않고 출발할 것이다.
- 릴리즈가 다가오면 어느 시점부터 완고한 자세로 개발자와 그들이 들고 온 새로운 기능을 외면해야 한다. 그 시점 이후로는 아무리 애원하고 구걸해도 이번 릴리즈에 끼워주지 않아야 한다.

## 24.5 품질과 사용자에 집중: 사용할 기능만 배포하자

- 대다수 소프트웨어는 사라지기 전에 팽창(bloat)이라는 불행한 부작용을 경험한다.
- 빠르고 효율적인 릴리즈 열차에도 이따금 지나치게 팽창해서 제품팀과 사용자에게까지 문제를 일으킬 수 있다는 단점이 있다.
  - 소프트웨어가 모바일 앱 형태로 전달된다면 고객은 사용하지도 않을 기능들에 모바일 기기의 저장 공간, 내려받는 시간, 데이터 비용을 허비해야 한다. 반대로 개발자들은 느려진 빌드, 복잡한 배포, 드물게 튀어나오는 버그 처리라는 비용을 치러야 한다.
- 모듈화를 통해 동적으로 설정 가능한 배포 전략을 구사할 수 있다.
  - 사용자 기기 공간과 자원 활용 효율을 높여주는 전략이다. 이렇게 하지 않으면 고객들은 자신은 한 번도 사용하지 않을 기능이나 다른 기기에 대응한 코드까지 포함한 바이너리를 받아 설치해야 한다.
  - 동적 배포를 활용하면 각 고객에게 의미 있는 코드만으로 작게 구성한 바이너리를 배포할 수 있다. 또한 A/B 실험을 실행하여 특정 기능에 드는 비용과 그 기능이 제공할 고객 가치(혹은 비즈니스 가치)를 비교해볼 수도 있다.
- 이러한 프로세스를 갖추려면 비용을 선제적으로 지불해야 한다.
  - 고객에게 릴리즈하는 주기보다 내부 릴리즈 주기를 짧게 관리하는 데도 저항이 있을 것이고, 모두를 설득하기가 쉽진 않을 것이다.
  - 하지만 위험 관리, 개발자 속도, 빠른 혁신 관점에서 얻는 게 아주 크기 때문에 장기적으로 초기 비용 이상을 충분히 보상 받을 수 있을 것이다.

## 24.6 원점 회귀: 데이터에 기초해 더 일찍 결정하자

> 클라이언트 시장의 다양성은 문제가 아니라 현실이다.

- 릴리즈 승인 모델 변경
  - 종합적인 테스트가 현실적으로 불가능하다면 대표적인 테스트만을 목표로 한다.
  - 사용자 기반을 조금씩 늘려가며 배포하면 문제를 빠르게 수정할 수 있다.
  - 자동화된 A/B 릴리즈를 이용하면 릴리즈 품질 판별에 도움이 되는 통계적으로 중요한 결과를 얻을 수 있다. 피곤하게 대시보드만 쳐다보며 결정할 일이 없어진다.
- A/B 테스트는 사용자 기반이 충분하다면 며칠 혹은 몇 시간이면 통계적으로 유의미한 결과를 얻을 수 있다. 여기에 지표를 얻고 판단하는 과정까지 자동화하면 가드레일 지표에 영향이 없다고 판단할 만큼의 데이터가 쌓이는 즉시 더 많은 사용자에게 신버전을 배포해가며 릴리즈를 최단 기간에 해낼 수 있다.
- 물론 이 방식을 모든 앱에 적용할 수는 없으며, 사용자 수가 충분하지 않을 때는 부담이 클 수 있다. 이런 경우라면 변경 중릭적인 릴리즈를 추천한다. 
  - 새로운 기능 모두를 플래그로 막아두고 배포하는 것이다. 그러면 배포 과정에서는 유일하게 배포 자체의 안정성만을 검증할 수 있다.
