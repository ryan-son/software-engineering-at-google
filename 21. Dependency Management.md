# 21. 의존성 관리

- 의존성 관리(dependency management): 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일
- 이 장에서 다루는 것
  - 외부 의존성의 버전을 업데이트하는 방법은 무엇인가?
  - 버전을 기술하는 방법은 무엇인가?
  - 의존성에서 어떤 유형의 변경이 허용되거나 예상되는가?
  - 다른 조직에서 만든 코드에 의존하는 게 직접 만드는 것보다 낫다고 판단하는 기준은 무엇인가?
- 의존성 관리는 시간과 확장 양 축 모두에서 복잡도를 키운다.
  - 소스 관리에서는 코드를 변경할 때 테스트를 수행하고 기존 코드를 손상시키지 않아야 한다. 코드베이스가 공유되어 있어서 무엇이 어떻게 이용되는지 볼 수 있고 우리가 직접 빌드하고 테스트할 수 있다.
  - 반면 의존성 관리는 우리에게 접근 권한이 없거나 속을 들여다볼 수 없는, 조직 외부에서 이루어지는 변경 때문에 일어나는 문제를 다룬다. 업스트림 의존성들(upstream dependencies)은 내가 작성한 코드와 손발을 맞출 수 없으므로 내 빌드나 테스트를 실패하게 만들 가능성이 더 크다.
    - 이런 의존성은 어떻게 관리해야 하는가? 외부 의존성을 만들지 말아야 하는가? 외부 의존성 메인테이너들에게 연락하여 릴리즈들 간에 일관성을 더 잘 지켜달라고 요구할 것인가? 언제 새 버전으로 갈아타야 하는가?
- 확장이 끼어들면 상황이 한층 더 복잡해진다. 우리는 일반적으로 수많은 외부 의존성들로 이루어진 거대한 네트워크를 다루기 때문이다.
- '다른 조건이 모두 같다면 의존성 관리 문제보다는 소스 관리 문제를 택하라'. 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴하다.
- 의존성을 관리할 때 극복해야 하는 문제, 해법, 한계를 다룬다.

## 21.1 의존성 관리가 어려운 이유

- 의존성 하나를 관리하는 방법이 중요한 게 아니다. 수많은 의존성들로 구성된 네트워크와 그 네트워크에 미래에 일어날 변화까지 고려해 관리하는 방법을 강구해야 한다.

### 21.1.1 요구사항 충돌과 다이아몬드 의존성

- 의존성 관리에서는 의존성 네트워크를 중심에 두고 생각해야 한다.
- 버전 비호환 문제의 대표적인 예는 다이아몬드 의존성 문제(diamond dependency problem)이다.
- 다이아몬드 의존성 문제 혹은 다른 형태의 요구사항 충돌 문제가 성립하려면 의존성 계층이 최소 세 개가 필요하다.
- 다이아몬드 의존성 문제가 주는 충격은 프로그래밍 언어에 따라 다르다.
  - 어떤 언어에서는 빌드 하나에 의존성 여러 버전을 모두 포함시킬 수 있다. 예를 들어 자바는 의존성이 제공하는 심볼의 이름을 바꾸는 메커니즘이 잘 정립되어 있다.
  - 이와 달리 C++는 다이아몬드 의존성에 대한 내성이 전혀 없다시피 하여 십중팔구 예기치 못한 버그나 정의되지 않은 동작(undefined behavior)으로 이어진다.
- 심볼을 숨기거나 이름을 바꿔 컴파일한 라이브러리를 중복 적재하는 방식은 다이아몬드 문제의 충격을 다소 완화해주지만 보편적인 해결책이 될 순 없다.
- 이러한 요구사항 충돌 문제를 쉽게 해결하는 유일한 방법은 모두와 호환되는 더 상위 혹은 하위 버전의 라이브러리를 찾는 것 뿐이다. 이게 불가능하다면 문제가 되는 의존성을 로컬에서 따로 패치해야 한다.
- '소통하지 않는 단체들이 각자의 계획대로 업그레이드를 진행하면서도 요구사항 충돌을 피할 수 있는 방법은 무엇일까?'

## 21.2 의존성 임포트하기

- 프로그래밍 측면에서 보면 직접 처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명히 더 낫다.
- 요구사항을 만족하는 외부 소프트웨어(의존성)가 있다면 이용하는 게 좋다.

### 21.2.1 호환성 약속

- 개발 비용을 줄일 수 있다고 해서 의존성을 임포트하는 게 꼭 옳은 선택은 아니다. 
  - 지속적인 유지보수 비용까지 감안해야 한다. 
  - 업그레이드할 계획이 없던 의존성이라 해도 보안 취약점이 발견될 수 있다.
  - 외부 요인 때문에 플랫폼을 갈아타야 할 수 있다.
- 의존성의 유지보수 비용을 조금 더 정확하게 계산할 수 있게 도와주는 질문들
  - 호환성이 얼마나 잘 지켜지는가?
  - 진화가 얼마나 빠르게(크게) 이루어지는가?
  - 변경 처리 방법은 무엇인가?
  - 각 버전의 지원 기간은 어떻게 되는가?

---

#### C++

- C++ 표준 라이브러리는 거의 무한대의 하위 호환성을 제공하는 예이다.
- API 호환성 뿐 아니라 바이너리 아티팩트들과의 하위 호환성도 꾸준히 제공해준다. 이를 ABI 호환성(application binary interface compatibility)이라 한다.
- 자바도 비슷하다. 소스 코드는 언어 버전이 올라가도 호환되며, 옛 버전의 JAR 파일이 새 버전 파일들과 어울려 구동된다.

#### Go

- Go 언어는 대부분의 릴리즈에서 소스 코드가 호환되게 해주었지만 바이너리는 그렇지 않았다.
- Go 언어에서는 빌드한 버전이 다른 바이너리끼리는 링크할 수 없다.

#### Abseil

- 성능을 더 끌어낼 수 있다면(그래서 구글 서비스 대부분이 혜택 받을 수 있다면) 구현 세부사항과 ABI를 변경할 권한이 구글에게 주어진다는 뜻이다.

#### Boost

- Boost는 버전 간 호환성을 보장하지 않는다. 따라서 Boost 사용자들은 호환성 문제가 생기기 전까지만 업그레이드 하는 게 바람직하다.

---

- 우리의 관심은 의존성들이 점차 변해갈 텐데 어떻게 하면 항상 최신 상태로 유지할 것인가이다.
- 구글에서는 엔지니어들이 '동작하게 만들었다'와 '지원되는 방식으로 동작한다'를 구분하여 생각하는 데 도움되는 지침들을 꾸준히 공유한다.

### 21.2.2 임포트 시 고려사항

- 프로그래밍 프로젝트라면 의존성 임포트는 거의 공짜에 가깝다. 필요한 기능을 제공하는지 확인했고 숨겨진 보안 취약점이 없다고 가정한다면 같은 기능을 직접 새로 구현하는 것보다는 이미 있는 것을 사용하는 게 당연히 저렴하다.
- 구글은 의존성을 임포트하려는 엔지니어들에게 몇 가지 질문들을 던져보라고 권한다.
  - 의존성 자체에 대한 질문
    - 실행해볼 수 있는 테스트가 딸려 있는 프로젝트인가?
    - 테스트는 모두 통과하는가?
    - 의존성 제공자는 누구인가? 똑같이 호환성을 보장하지 않는 오픈 소스 프로젝트더라도 경험과 기술력 차이는 어마어마할 수 있다. 최소한 호환성 측면에서는 C++ 표준 라이브러리나 자바의 Guava 라이브러리를 사용하는 것과 깃허브나 npm에서 임의의 프로젝트를 선택해 사용하는 것은 매우 다른 이야기다. 유명하다고 다 좋은 것은 아니지만 반드시 고려해보는 게 좋다.
    - 지향하는 호환성 정책은 어떠한가?
    - 앞으로 어떤 분야나 용도를 지원해나갈 것인지 자세히 설명하고 있는가?
    - 얼마나 인기 있는 프로젝트인가?
    - 언제까지 이용할 것인가?
    - 파괴적인 변경이 얼마나 빈번하게 행해지고 있는가?
  - 소속된 조직 관점에서의 질문
    - 구글이 같은 기능을 새로 구현하려면 얼마나 복잡한가?
    - 그 의존성을 최신 상태로 유지하면 어떤 이점이 있는가?
    - 업그레이드는 누가 할 것인가?
    - 업그레이드하는 난이도는 어느 정도일 거라 예상하는가?
- 긴 안목에서 임포트와 재구현 중 어느 쪽이 저렴할지를 예측해줄 완벽한 공식은 아무도 모른다.

### 21.2.3 의존성 임포트하기 @구글

- 구글 프로젝트들이 이용하는 의존성들의 압도적 다수는 구글이 개발했다. 구글의 내부 의존성 관리의 대다수는 사실 진정한 의존성 관리가 아니라는 뜻이다.
- 구글이 의존성을 추가하는 과정
  1. 구글 빌드 시스템에서 잘 빌드되는지 확인한다.
  2. 같은 패키지가 이미 존재하지 않음을 확인한다(버전만 다른 경우 포함).
  3. 유지보수를 맡아줄 엔지니어를 찾아 OWNERS에 추가한다(최소 두 명).
- 코드베이스에 패키지가 오래 머무를수록 직간접적인 의존성의 수가 계속 늘어날 가능성이 높다. 패키지가 변하지 않는 기간이 늘어날수록 third_party에 추가된 특정 버전을 하이럼의 법칙이 점점 더 강하게 옥죌 것이다. 나중에 다른 버전으로 마이그레이션하기가 그만큼 어려워진다는 뜻이다.

## 21.3 (이론상의) 의존성 관리

- 훌륭한 해법이라면 모든 형태의 요구사항 충돌 문제로부터 우리를 보호해줘야 한다(예: 다이아몬드 의존성 버전 충돌).
- 언제든 새로운 의존 관계나 요구사항이 추가될 수 있는 동적인 생태계에서조차 통하는 해법이어야 한다.
- 안정적인 의존성 관리 체계란 시간과 규모 모든 면에서 유연해야 한다. 의존성 그래프의 어느 노드라도 영원히 변치 않으리라 가정해서는 안 된다.
- 의존성 관리 해법 네 가지. 변경 불가, 유의적 버전, 하나로 묶어 배포하기, 헤드에서 지내기.

### 21.3.1 변경 불가(정적 의존성 모델)

- 애초부터 변경 자체를 허용하지 않으면 기존 의존성 때문에 불안해할 일이 사라진다.
- 변경 불가는 대부분의 신생 조직에게는 적합한 모델일 수 있다. 새로 시작하는 프로젝트가 수십 년을 살아남고, 그래서 의존성을 물 흐르듯 업데이드해야 할 필요가 있을지를 알고 시작하는 경우는 흔치 않다. 그래서 프로젝트의 처음 몇 해는 의존성들이 완벽하게 안정적일 거라 가정하고 진행하는 게 훨씬 합리적일 것이다.
- 프로젝트가 오래 살아남을수록 가정이 틀릴 가능성이 커지며 언제가지 유효할지를 정확하게 알 수 없는 지표가 없다. 의존성을 업그레이드해야만 하는 보안 버그나 기타 중요한 문제가 언제 터질지를 알려줄 조기 경보 시스템이 존재하지 않는다. 의존성들은 서로 얽혀있기 때문에 이론상으로는 단 하나만 업그레이드하려다가 의존성 네트워크 전체를 업데이트해야만 하는 상황에 치달을 수도 있다.

### 21.3.2 유의적 버전(SemVer)

- 오늘날 의존성 네트워크를 관리하는 가장 대표적인 방법
- SemVer: 의존성의 버전을 표기하는 보편적인 방식.
  - 메이저: API가 변경되어 의존성을 이용하던 기존 코드를 깨뜨릴 수 있음
  - 마이너: 순수하게 기능 추가만 있음(기존 코드를 깨뜨리지 않음)
  - 패치: API에 영향을 주지 않는 내부 구현 개선과 버그 수정
- SemVer 기반 의존성 관리는 대체로 SAT 솔버를 이용한다.
- 버전 선택(version selection): 의존성 네트워크 전체를 대상으로 어떤 알고리즘을 수행하여 모든 버전 요구사항을 충족하는 의존성 버전을 찾는 행위
- 의존성 지옥(dependency hell): 만족스러운 버전 조합이 네트워크에 존재하지 않는 상황

### 21.3.3 하나로 묶어 배포하기

- 업계에서 수십 년 전부터 이용해온 강력한 의존성 관리 모델, 애플리케이션 구동에 필요한 의존성들을 모두 찾아서 애플리케이션과 함께 배포하는 방법(예: 리눅스 배포판)
- 이 모델에서는 새로운 역할인 배포자(distributor)가 등장한다. 개별 의존성의 메인테이너들은 다른 의존성들에 대해서는 거의 몰라도 된다. 더 거시적인 관리를 책임지는 배포자가 상호 호환되는 버전들을 찾고 패치하고 검증하는 일을 수행해주기 때문이다. 배포자는 함께 묶어 배포할 버전들을 찾고, 이 버전들로 채운 의존성 트리에서 문제가 없는지 확인하고, 문제가 생기면 해결하는 일을 담당한다.

### 21.3.4 헤드에서 지내기

- 몇몇이 구글에서 추진하는 모델.
- 이론적으로는 멋지지만 의존성 네트워크 참여자들에게 비싼 부담을 새로 지운다는 단점이 있다. 비용은 싸지 않지만 구글 같은 조직의 경계 안에서는 효과적이다.
- 트렁크 기반 개발을 의존성 관리 영역까지 확장한 걸로 보면 된다. 소스 관리 정책인 트렁크 기반 개발을 업스트림 의존성에까지 적용한 모델이다.
- SemVer를 버리고 의존성 제공자가 변경사항을 커밋하기 전에 생태계 전체를 대상으로 검증하게 한다.
- 헤드에서 지내기는 의존성 관리에서 시간과 선택이라는 요소를 제거하려는 시도다. 모든 컴포넌트가 항상 최신 버전에 의존하며, 의존하는 쪽에서 수용하기 어려운 형태의 변경은 절대 허용하지 않는다. 의도치 않게 API나 행위가 달라지게 하는 변경은 일반적으로 다운스트림 의존성의 CI에서 포착되므로 커밋되지 않도록 한다.
- 변경이 다운스트림 고객들에게 미치는 영향을 검증하는 부담이 API 제공자에게 주어진다.
- 헤드에서 지내기는 다음과 같은 상황들을 가정한다.
  - 단위 테스트와 CI가 갖춰져 있다.
  - API 제공자 다운스트림 의존성들이 깨지는지를 확인할 수 있다.
  - API 소비자가 테스트들이 계속 통과되고 지원 가능한 방식으로 의존성을 이용 중이다.
- 얻을 수 있는 보상들
  - API 제공자: 변경이 소비자들에게 신속하고 매끄럽게 받아들여진다.
  - API 소비자: 테스트들이 쳐주는 보호막이 꺼질 일이 없다. 어느 날 갑자기 테스트가 실패하고, 원인이 무엇인지 또 언제 고쳐질지 파악하기 어렵다면 해당 테스트들을 아예 비활성화 해버릴지도 모른다.
