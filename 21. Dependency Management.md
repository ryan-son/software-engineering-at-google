# 21. 의존성 관리

- 의존성 관리(dependency management): 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일
- 이 장에서 다루는 것
  - 외부 의존성의 버전을 업데이트하는 방법은 무엇인가?
  - 버전을 기술하는 방법은 무엇인가?
  - 의존성에서 어떤 유형의 변경이 허용되거나 예상되는가?
  - 다른 조직에서 만든 코드에 의존하는 게 직접 만드는 것보다 낫다고 판단하는 기준은 무엇인가?
- 의존성 관리는 시간과 확장 양 축 모두에서 복잡도를 키운다.
  - 소스 관리에서는 코드를 변경할 때 테스트를 수행하고 기존 코드를 손상시키지 않아야 한다. 코드베이스가 공유되어 있어서 무엇이 어떻게 이용되는지 볼 수 있고 우리가 직접 빌드하고 테스트할 수 있다.
  - 반면 의존성 관리는 우리에게 접근 권한이 없거나 속을 들여다볼 수 없는, 조직 외부에서 이루어지는 변경 때문에 일어나는 문제를 다룬다. 업스트림 의존성들(upstream dependencies)은 내가 작성한 코드와 손발을 맞출 수 없으므로 내 빌드나 테스트를 실패하게 만들 가능성이 더 크다.
    - 이런 의존성은 어떻게 관리해야 하는가? 외부 의존성을 만들지 말아야 하는가? 외부 의존성 메인테이너들에게 연락하여 릴리즈들 간에 일관성을 더 잘 지켜달라고 요구할 것인가? 언제 새 버전으로 갈아타야 하는가?
- 확장이 끼어들면 상황이 한층 더 복잡해진다. 우리는 일반적으로 수많은 외부 의존성들로 이루어진 거대한 네트워크를 다루기 때문이다.
- '다른 조건이 모두 같다면 의존성 관리 문제보다는 소스 관리 문제를 택하라'. 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴하다.
- 의존성을 관리할 때 극복해야 하는 문제, 해법, 한계를 다룬다.

## 21.1 의존성 관리가 어려운 이유

- 의존성 하나를 관리하는 방법이 중요한 게 아니다. 수많은 의존성들로 구성된 네트워크와 그 네트워크에 미래에 일어날 변화까지 고려해 관리하는 방법을 강구해야 한다.

### 21.1.1 요구사항 충돌과 다이아몬드 의존성

- 의존성 관리에서는 의존성 네트워크를 중심에 두고 생각해야 한다.
- 버전 비호환 문제의 대표적인 예는 다이아몬드 의존성 문제(diamond dependency problem)이다.
- 다이아몬드 의존성 문제 혹은 다른 형태의 요구사항 충돌 문제가 성립하려면 의존성 계층이 최소 세 개가 필요하다.
- 다이아몬드 의존성 문제가 주는 충격은 프로그래밍 언어에 따라 다르다.
  - 어떤 언어에서는 빌드 하나에 의존성 여러 버전을 모두 포함시킬 수 있다. 예를 들어 자바는 의존성이 제공하는 심볼의 이름을 바꾸는 메커니즘이 잘 정립되어 있다.
  - 이와 달리 C++는 다이아몬드 의존성에 대한 내성이 전혀 없다시피 하여 십중팔구 예기치 못한 버그나 정의되지 않은 동작(undefined behavior)으로 이어진다.
- 심볼을 숨기거나 이름을 바꿔 컴파일한 라이브러리를 중복 적재하는 방식은 다이아몬드 문제의 충격을 다소 완화해주지만 보편적인 해결책이 될 순 없다.
- 이러한 요구사항 충돌 문제를 쉽게 해결하는 유일한 방법은 모두와 호환되는 더 상위 혹은 하위 버전의 라이브러리를 찾는 것 뿐이다. 이게 불가능하다면 문제가 되는 의존성을 로컬에서 따로 패치해야 한다.
- '소통하지 않는 단체들이 각자의 계획대로 업그레이드를 진행하면서도 요구사항 충돌을 피할 수 있는 방법은 무엇일까?'

## 21.2 의존성 임포트하기

- 프로그래밍 측면에서 보면 직접 처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명히 더 낫다.
- 요구사항을 만족하는 외부 소프트웨어(의존성)가 있다면 이용하는 게 좋다.

### 21.2.1 호환성 약속

- 개발 비용을 줄일 수 있다고 해서 의존성을 임포트하는 게 꼭 옳은 선택은 아니다. 
  - 지속적인 유지보수 비용까지 감안해야 한다. 
  - 업그레이드할 계획이 없던 의존성이라 해도 보안 취약점이 발견될 수 있다.
  - 외부 요인 때문에 플랫폼을 갈아타야 할 수 있다.
- 의존성의 유지보수 비용을 조금 더 정확하게 계산할 수 있게 도와주는 질문들
  - 호환성이 얼마나 잘 지켜지는가?
  - 진화가 얼마나 빠르게(크게) 이루어지는가?
  - 변경 처리 방법은 무엇인가?
  - 각 버전의 지원 기간은 어떻게 되는가?

---

#### C++

- C++ 표준 라이브러리는 거의 무한대의 하위 호환성을 제공하는 예이다.
- API 호환성 뿐 아니라 바이너리 아티팩트들과의 하위 호환성도 꾸준히 제공해준다. 이를 ABI 호환성(application binary interface compatibility)이라 한다.
- 자바도 비슷하다. 소스 코드는 언어 버전이 올라가도 호환되며, 옛 버전의 JAR 파일이 새 버전 파일들과 어울려 구동된다.

#### Go

- Go 언어는 대부분의 릴리즈에서 소스 코드가 호환되게 해주었지만 바이너리는 그렇지 않았다.
- Go 언어에서는 빌드한 버전이 다른 바이너리끼리는 링크할 수 없다.

#### Abseil

- 성능을 더 끌어낼 수 있다면(그래서 구글 서비스 대부분이 혜택 받을 수 있다면) 구현 세부사항과 ABI를 변경할 권한이 구글에게 주어진다는 뜻이다.

#### Boost

- Boost는 버전 간 호환성을 보장하지 않는다. 따라서 Boost 사용자들은 호환성 문제가 생기기 전까지만 업그레이드 하는 게 바람직하다.

---

- 우리의 관심은 의존성들이 점차 변해갈 텐데 어떻게 하면 항상 최신 상태로 유지할 것인가이다.
- 구글에서는 엔지니어들이 '동작하게 만들었다'와 '지원되는 방식으로 동작한다'를 구분하여 생각하는 데 도움되는 지침들을 꾸준히 공유한다.
