# 21. 의존성 관리

- 의존성 관리(dependency management): 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일
- 이 장에서 다루는 것
  - 외부 의존성의 버전을 업데이트하는 방법은 무엇인가?
  - 버전을 기술하는 방법은 무엇인가?
  - 의존성에서 어떤 유형의 변경이 허용되거나 예상되는가?
  - 다른 조직에서 만든 코드에 의존하는 게 직접 만드는 것보다 낫다고 판단하는 기준은 무엇인가?
- 의존성 관리는 시간과 확장 양 축 모두에서 복잡도를 키운다.
  - 소스 관리에서는 코드를 변경할 때 테스트를 수행하고 기존 코드를 손상시키지 않아야 한다. 코드베이스가 공유되어 있어서 무엇이 어떻게 이용되는지 볼 수 있고 우리가 직접 빌드하고 테스트할 수 있다.
  - 반면 의존성 관리는 우리에게 접근 권한이 없거나 속을 들여다볼 수 없는, 조직 외부에서 이루어지는 변경 때문에 일어나는 문제를 다룬다. 업스트림 의존성들(upstream dependencies)은 내가 작성한 코드와 손발을 맞출 수 없으므로 내 빌드나 테스트를 실패하게 만들 가능성이 더 크다.
    - 이런 의존성은 어떻게 관리해야 하는가? 외부 의존성을 만들지 말아야 하는가? 외부 의존성 메인테이너들에게 연락하여 릴리즈들 간에 일관성을 더 잘 지켜달라고 요구할 것인가? 언제 새 버전으로 갈아타야 하는가?
- 확장이 끼어들면 상황이 한층 더 복잡해진다. 우리는 일반적으로 수많은 외부 의존성들로 이루어진 거대한 네트워크를 다루기 때문이다.
- '다른 조건이 모두 같다면 의존성 관리 문제보다는 소스 관리 문제를 택하라'. 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴하다.
- 의존성을 관리할 때 극복해야 하는 문제, 해법, 한계를 다룬다.

## 21.1 의존성 관리가 어려운 이유

- 의존성 하나를 관리하는 방법이 중요한 게 아니다. 수많은 의존성들로 구성된 네트워크와 그 네트워크에 미래에 일어날 변화까지 고려해 관리하는 방법을 강구해야 한다.

### 21.1.1 요구사항 충돌과 다이아몬드 의존성

- 의존성 관리에서는 의존성 네트워크를 중심에 두고 생각해야 한다.
- 버전 비호환 문제의 대표적인 예는 다이아몬드 의존성 문제(diamond dependency problem)이다.
- 다이아몬드 의존성 문제 혹은 다른 형태의 요구사항 충돌 문제가 성립하려면 의존성 계층이 최소 세 개가 필요하다.
- 다이아몬드 의존성 문제가 주는 충격은 프로그래밍 언어에 따라 다르다.
  - 어떤 언어에서는 빌드 하나에 의존성 여러 버전을 모두 포함시킬 수 있다. 예를 들어 자바는 의존성이 제공하는 심볼의 이름을 바꾸는 메커니즘이 잘 정립되어 있다.
  - 이와 달리 C++는 다이아몬드 의존성에 대한 내성이 전혀 없다시피 하여 십중팔구 예기치 못한 버그나 정의되지 않은 동작(undefined behavior)으로 이어진다.
- 심볼을 숨기거나 이름을 바꿔 컴파일한 라이브러리를 중복 적재하는 방식은 다이아몬드 문제의 충격을 다소 완화해주지만 보편적인 해결책이 될 순 없다.
- 이러한 요구사항 충돌 문제를 쉽게 해결하는 유일한 방법은 모두와 호환되는 더 상위 혹은 하위 버전의 라이브러리를 찾는 것 뿐이다. 이게 불가능하다면 문제가 되는 의존성을 로컬에서 따로 패치해야 한다.
- '소통하지 않는 단체들이 각자의 계획대로 업그레이드를 진행하면서도 요구사항 충돌을 피할 수 있는 방법은 무엇일까?'

## 21.2 의존성 임포트하기

- 프로그래밍 측면에서 보면 직접 처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명히 더 낫다.
- 요구사항을 만족하는 외부 소프트웨어(의존성)가 있다면 이용하는 게 좋다.

### 21.2.1 호환성 약속

- 개발 비용을 줄일 수 있다고 해서 의존성을 임포트하는 게 꼭 옳은 선택은 아니다. 
  - 지속적인 유지보수 비용까지 감안해야 한다. 
  - 업그레이드할 계획이 없던 의존성이라 해도 보안 취약점이 발견될 수 있다.
  - 외부 요인 때문에 플랫폼을 갈아타야 할 수 있다.
- 의존성의 유지보수 비용을 조금 더 정확하게 계산할 수 있게 도와주는 질문들
  - 호환성이 얼마나 잘 지켜지는가?
  - 진화가 얼마나 빠르게(크게) 이루어지는가?
  - 변경 처리 방법은 무엇인가?
  - 각 버전의 지원 기간은 어떻게 되는가?

---

#### C++

- C++ 표준 라이브러리는 거의 무한대의 하위 호환성을 제공하는 예이다.
- API 호환성 뿐 아니라 바이너리 아티팩트들과의 하위 호환성도 꾸준히 제공해준다. 이를 ABI 호환성(application binary interface compatibility)이라 한다.
- 자바도 비슷하다. 소스 코드는 언어 버전이 올라가도 호환되며, 옛 버전의 JAR 파일이 새 버전 파일들과 어울려 구동된다.

#### Go

- Go 언어는 대부분의 릴리즈에서 소스 코드가 호환되게 해주었지만 바이너리는 그렇지 않았다.
- Go 언어에서는 빌드한 버전이 다른 바이너리끼리는 링크할 수 없다.

#### Abseil

- 성능을 더 끌어낼 수 있다면(그래서 구글 서비스 대부분이 혜택 받을 수 있다면) 구현 세부사항과 ABI를 변경할 권한이 구글에게 주어진다는 뜻이다.

#### Boost

- Boost는 버전 간 호환성을 보장하지 않는다. 따라서 Boost 사용자들은 호환성 문제가 생기기 전까지만 업그레이드 하는 게 바람직하다.

---

- 우리의 관심은 의존성들이 점차 변해갈 텐데 어떻게 하면 항상 최신 상태로 유지할 것인가이다.
- 구글에서는 엔지니어들이 '동작하게 만들었다'와 '지원되는 방식으로 동작한다'를 구분하여 생각하는 데 도움되는 지침들을 꾸준히 공유한다.

### 21.2.2 임포트 시 고려사항

- 프로그래밍 프로젝트라면 의존성 임포트는 거의 공짜에 가깝다. 필요한 기능을 제공하는지 확인했고 숨겨진 보안 취약점이 없다고 가정한다면 같은 기능을 직접 새로 구현하는 것보다는 이미 있는 것을 사용하는 게 당연히 저렴하다.
- 구글은 의존성을 임포트하려는 엔지니어들에게 몇 가지 질문들을 던져보라고 권한다.
  - 의존성 자체에 대한 질문
    - 실행해볼 수 있는 테스트가 딸려 있는 프로젝트인가?
    - 테스트는 모두 통과하는가?
    - 의존성 제공자는 누구인가? 똑같이 호환성을 보장하지 않는 오픈 소스 프로젝트더라도 경험과 기술력 차이는 어마어마할 수 있다. 최소한 호환성 측면에서는 C++ 표준 라이브러리나 자바의 Guava 라이브러리를 사용하는 것과 깃허브나 npm에서 임의의 프로젝트를 선택해 사용하는 것은 매우 다른 이야기다. 유명하다고 다 좋은 것은 아니지만 반드시 고려해보는 게 좋다.
    - 지향하는 호환성 정책은 어떠한가?
    - 앞으로 어떤 분야나 용도를 지원해나갈 것인지 자세히 설명하고 있는가?
    - 얼마나 인기 있는 프로젝트인가?
    - 언제까지 이용할 것인가?
    - 파괴적인 변경이 얼마나 빈번하게 행해지고 있는가?
  - 소속된 조직 관점에서의 질문
    - 구글이 같은 기능을 새로 구현하려면 얼마나 복잡한가?
    - 그 의존성을 최신 상태로 유지하면 어떤 이점이 있는가?
    - 업그레이드는 누가 할 것인가?
    - 업그레이드하는 난이도는 어느 정도일 거라 예상하는가?
- 긴 안목에서 임포트와 재구현 중 어느 쪽이 저렴할지를 예측해줄 완벽한 공식은 아무도 모른다.

### 21.2.3 의존성 임포트하기 @구글

- 구글 프로젝트들이 이용하는 의존성들의 압도적 다수는 구글이 개발했다. 구글의 내부 의존성 관리의 대다수는 사실 진정한 의존성 관리가 아니라는 뜻이다.
- 구글이 의존성을 추가하는 과정
  1. 구글 빌드 시스템에서 잘 빌드되는지 확인한다.
  2. 같은 패키지가 이미 존재하지 않음을 확인한다(버전만 다른 경우 포함).
  3. 유지보수를 맡아줄 엔지니어를 찾아 OWNERS에 추가한다(최소 두 명).
- 코드베이스에 패키지가 오래 머무를수록 직간접적인 의존성의 수가 계속 늘어날 가능성이 높다. 패키지가 변하지 않는 기간이 늘어날수록 third_party에 추가된 특정 버전을 하이럼의 법칙이 점점 더 강하게 옥죌 것이다. 나중에 다른 버전으로 마이그레이션하기가 그만큼 어려워진다는 뜻이다.
